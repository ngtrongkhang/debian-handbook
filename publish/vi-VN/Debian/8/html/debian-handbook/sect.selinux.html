<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>14.5. Introduction to SELinux</title><meta name="generator" content="publican v4.3.2"/><meta name="keywords" content="Tường lửa, Netfilter, IDS/NIDS"/><link rel="prev" href="sect.apparmor.html" title="14.4. Introduction to AppArmor"/><link rel="next" href="sect.other-security-considerations.html" title="14.6. Other Security-Related Considerations"/><link xmlns="" rel="canonical" href="https://debian-handbook.info/browse/vi-VN/stable/sect.selinux.html"/></head><body onLoad="initSwitchery(); jQuery(&quot;#poptoc&quot;).load('index.html .toc:eq(0)'); jQuery('.programlisting').each(function(i, block){hljs.highlightBlock(block);});" onClick="hide('poptoc');"><header><div id="banner"><a href="http://debian-handbook.info/get/"><span class="text">Download the ebook</span></a></div><ul class="docnav top"><li class="previous"><a accesskey="p" href="sect.apparmor.html"><strong>Trước đó</strong></a></li><li class="home" onClick="work=1;showhide('poptoc');">Sổ tay Quản trị Debian</li><li class="next"><a accesskey="n" href="sect.other-security-considerations.html"><strong>Kế tiếp</strong></a></li></ul></header><div id="poptoc" class="hidden"> </div><section class="section" id="sect.selinux"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.selinux"/>14.5. Introduction to SELinux</h2></div></div></div>
		
		 <a id="id-1.17.8.2" class="indexterm"></a>
		 <section class="section" id="sect.selinux-principles"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.selinux-principles"/>14.5.1. Principles</h3></div></div></div>
			
			 <p>
				SELinux (<span class="emphasis"><em>Security Enhanced Linux</em></span>) is a <span class="emphasis"><em>Mandatory Access Control</em></span> system built on Linux's LSM (<span class="emphasis"><em>Linux Security Modules</em></span>) interface. In practice, the kernel queries SELinux before each system call to know whether the process is authorized to do the given operation.
			</p>
			 <p>
				SELinux uses a set of rules — collectively known as a <span class="emphasis"><em>policy</em></span> — to authorize or forbid operations. Those rules are difficult to create. Fortunately, two standard policies (<span class="emphasis"><em>targeted</em></span> and <span class="emphasis"><em>strict</em></span>) are provided to avoid the bulk of the configuration work.
			</p>
			 <p>
				With SELinux, the management of rights is completely different from traditional Unix systems. The rights of a process depend on its <span class="emphasis"><em>security context</em></span>. The context is defined by the <span class="emphasis"><em>identity</em></span> of the user who started the process, the <span class="emphasis"><em>role</em></span> and the <span class="emphasis"><em>domain</em></span> that the user carried at that time. The rights really depend on the domain, but the transitions between domains are controlled by the roles. Finally, the possible transitions between roles depend on the identity.
			</p>
			 <div class="figure" id="id-1.17.8.3.5"><a id="id-1.17.8.3.5"/><p class="title"><strong>Hình 14.3. Security contexts and Unix users</strong></p><div class="figure-contents">
				
				 <div class="mediaobject"><img src="images/selinux-context.png" alt="Security contexts and Unix users"/></div>

			</div></div>
			 <p>
				In practice, during login, the user gets assigned a default security context (depending on the roles that they should be able to endorse). This defines the current domain, and thus the domain that all new child processes will carry. If you want to change the current role and its associated domain, you must call <span class="command"><strong>newrole -r <em class="replaceable">role_r</em> -t <em class="replaceable">domain_t</em></strong></span> (there's usually only a single domain allowed for a given role, the <code class="literal">-t</code> parameter can thus often be left out). This command authenticates you by asking you to type your password. This feature forbids programs to automatically switch roles. Such changes can only happen if they are explicitly allowed in the SELinux policy.
			</p>
			 <p>
				Obviously the rights do not apply to all <span class="emphasis"><em>objects</em></span> (files, directories, sockets, devices, etc.). They can vary from object to object. To achieve this, each object is associated to a <span class="emphasis"><em>type</em></span> (this is known as labeling). Domains' rights are thus expressed with sets of (dis)allowed operations on those types (and, indirectly, on all objects which are labeled with the given type).
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>EXTRA</em></span> Domains and types are equivalent</strong></p></div></div></div> 
			 <p>
				Internally, a domain is just a type, but a type that only applies to processes. That's why domains are suffixed with <code class="literal">_t</code> just like objects' types.
			</p>
			 </div> <p>
				By default, a program inherits its domain from the user who started it, but the standard SELinux policies expect many important programs to run in dedicated domains. To achieve this, those executables are labeled with a dedicated type (for example <span class="command"><strong>ssh</strong></span> is labeled with <code class="literal">ssh_exec_t</code>, and when the program starts, it automatically switches to the <code class="literal">ssh_t</code> domain). This automatic domain transition mechanism makes it possible to grant only the rights required by each program. It is a fundamental principle of SELinux.
			</p>
			 <div class="figure" id="id-1.17.8.3.10"><a id="id-1.17.8.3.10"/><p class="title"><strong>Hình 14.4. Automatic transitions between domains</strong></p><div class="figure-contents">
				
				 <div class="mediaobject"><img src="images/selinux-transitions.png" alt="Automatic transitions between domains"/></div>

			</div></div>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>IN PRACTICE</em></span> Finding the security context</strong></p></div></div></div> 
			 <a id="id-1.17.8.3.11.2" class="indexterm"></a>
			 <a id="id-1.17.8.3.11.3" class="indexterm"></a>
			 <a id="id-1.17.8.3.11.4" class="indexterm"></a>
			 <p>
				To find the security context of a given process, you should use the <code class="literal">Z</code> option of <span class="command"><strong>ps</strong></span>.
			</p>
			 
<pre class="screen"><code class="computeroutput">$ </code><strong class="userinput"><code>ps axZ | grep vstfpd</code></strong>
<code class="computeroutput">system_u:system_r:ftpd_t:s0 2094 ? Ss 0:00 /usr/sbin/vsftpd</code></pre>
			 <p>
				The first field contains the identity, the role, the domain and the MCS level, separated by colons. The MCS level (<span class="emphasis"><em>Multi-Category Security</em></span>) is a parameter that intervenes in the setup of a confidentiality protection policy, which regulates the access to files based on their sensitivity. This feature will not be explained in this book.
			</p>
			 <p>
				To find the current security context in a shell, you should call <span class="command"><strong>id -Z</strong></span>.
			</p>
			 
<pre class="screen"><code class="computeroutput">$ </code><strong class="userinput"><code>id -Z</code></strong>
<code class="computeroutput">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre>
			 <p>
				Finally, to find the type assigned to a file, you can use <span class="command"><strong>ls -Z</strong></span>.
			</p>
			 
<pre class="screen"><code class="computeroutput">$ </code><strong class="userinput"><code>ls -Z test /usr/bin/ssh</code></strong>
<code class="computeroutput">unconfined_u:object_r:user_home_t:s0 test system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</code></pre>
			 <p>
				It is worth noting that the identity and role assigned to a file bear no special importance (they are never used), but for the sake of uniformity, all objects get assigned a complete security context.
			</p>
			 </div>
		</section>
		 <section class="section" id="sect.selinux-setup"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.selinux-setup"/>14.5.2. Setting Up SELinux</h3></div></div></div>
			
			 <p>
				SELinux support is built into the standard kernels provided by Debian. The core Unix tools support SELinux without any modifications. It is thus relatively easy to enable SELinux.
			</p>
			 <p>
				The <span class="command"><strong>apt install selinux-basics selinux-policy-default</strong></span> command will automatically install the packages required to configure an SELinux system.
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>CAUTION</em></span> Reference policy not in jessie</strong></p></div></div></div> 
			 <p>
				Unfortunately the maintainers of the <span class="pkg pkg">refpolicy</span> source package did not handle release critical bugs on their package and the package got removed from jessie. This means that the <span class="pkg pkg">selinux-policy-*</span> packages are currently not installable in jessie and need to be fetched from another place. Hopefully they will come back in one of the point releases or in jessie-backports. In the meantime, you can grab them from unstable.
			</p>
			 <p>
				This sad situation at least proves that SELinux is not very popular in the set of users/developers who are running the development versions of Debian. Thus, if you opt to use SELinux, you should expect the default policy to not work perfectly and you will have to invest quite some time to make it suitable to your specific needs.
			</p>
			 </div> <p>
				The <span class="pkg pkg">selinux-policy-default</span> package contains a set of standard rules. By default, this policy only restricts access for a few widely exposed services. The user sessions are not restricted and it is thus unlikely that SELinux would block legitimate user operations. However, this does enhance the security of system services running on the machine. To setup a policy equivalent to the old “strict” rules, you just have to disable the <code class="literal">unconfined</code> module (modules management is detailed further in this section).
			</p>
			 <p>
				Once the policy has been installed, you should label all the available files (which means assigning them a type). This operation must be manually started with <span class="command"><strong>fixfiles relabel</strong></span>.
			</p>
			 <p>
				The SELinux system is now ready. To enable it, you should add the <code class="literal">selinux=1 security=selinux</code> parameter to the Linux kernel. The <code class="literal">audit=1</code> parameter enables SELinux logging which records all the denied operations. Finally, the <code class="literal">enforcing=1</code> parameter brings the rules into application: without it SELinux works in its default <span class="emphasis"><em>permissive</em></span> mode where denied actions are logged but still executed. You should thus modify the GRUB bootloader configuration file to append the desired parameters. One easy way to do this is to modify the <code class="literal">GRUB_CMDLINE_LINUX</code> variable in <code class="filename">/etc/default/grub</code> and to run <span class="command"><strong>update-grub</strong></span>. SELinux will be active after a reboot.
			</p>
			 <p>
				It is worth noting that the <span class="command"><strong>selinux-activate</strong></span> script automates those operations and forces a labeling on next boot (which avoids new non-labeled files created while SELinux was not yet active and while the labeling was going on).
			</p>

		</section>
		 <section class="section" id="sect.selinux-management"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.selinux-management"/>14.5.3. Managing an SELinux System</h3></div></div></div>
			
			 <a id="id-1.17.8.5.2" class="indexterm"></a>
			 <a id="id-1.17.8.5.3" class="indexterm"></a>
			 <p>
				The SELinux policy is a modular set of rules, and its installation detects and enables automatically all the relevant modules based on the already installed services. The system is thus immediately operational. However, when a service is installed after the SELinux policy, you must be able to manually enable the corresponding module. That is the purpose of the <span class="command"><strong>semodule</strong></span> command. Furthermore, you must be able to define the roles that each user can endorse, and this can be done with the <span class="command"><strong>semanage</strong></span> command.
			</p>
			 <p>
				Those two commands can thus be used to modify the current SELinux configuration, which is stored in <code class="filename">/etc/selinux/default/</code>. Unlike other configuration files that you can find in <code class="filename">/etc/</code>, all those files must not be changed by hand. You should use the programs designed for this purpose.
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>GOING FURTHER</em></span> More documentation</strong></p></div></div></div> 
			 <p>
				Since the NSA doesn't provide any official documentation, the community set up a wiki to compensate. It brings together a lot of information, but you must be aware that most SELinux contributors are Fedora users (where SELinux is enabled by default). The documentation thus tends to deal specifically with that distribution. <a class="ulink" href="http://www.selinuxproject.org">http://www.selinuxproject.org</a>
			</p>
			 <p>
				You should also have a look at the dedicated Debian wiki page as well as Russell Coker's blog, who is one of the most active Debian developers working on SELinux support. <a class="ulink" href="http://wiki.debian.org/SELinux">http://wiki.debian.org/SELinux</a> <a class="ulink" href="http://etbe.coker.com.au/tag/selinux/">http://etbe.coker.com.au/tag/selinux/</a>
			</p>
			 </div> <section class="section" id="id-1.17.8.5.7"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.17.8.5.7"/>14.5.3.1. Managing SELinux Modules</h4></div></div></div>
				
				 <p>
					Available SELinux modules are stored in the <code class="filename">/usr/share/selinux/default/</code> directory. To enable one of these modules in the current configuration, you should use <span class="command"><strong>semodule -i <em class="replaceable">module.pp.bz2</em></strong></span>. The <span class="emphasis"><em>pp.bz2</em></span> extension stands for <span class="emphasis"><em>policy package</em></span> (compressed with bzip2).
				</p>
				 <p>
					Removing a module from the current configuration is done with <span class="command"><strong>semodule -r <em class="replaceable">module</em></strong></span>. Finally, the <span class="command"><strong>semodule -l</strong></span> command lists the modules which are currently installed. It also outputs their version numbers. Modules can be selectively enabled with <span class="command"><strong>semodule -e</strong></span> and disabled with <span class="command"><strong>semodule -d</strong></span>.
				</p>
				 
<pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>semodule -i /usr/share/selinux/default/abrt.pp.bz2</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>semodule -l</code></strong>
<code class="computeroutput">abrt 1.5.0 Disabled accountsd 1.1.0 acct 1.6.0 [...]</code>
<code class="computeroutput"># </code><strong class="userinput"><code>semodule -e abrt</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>semodule -d accountsd</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>semodule -l</code></strong>
<code class="computeroutput">abrt 1.5.0 accountsd 1.1.0 Disabled acct 1.6.0 [...]</code>
<code class="computeroutput"># </code><strong class="userinput"><code>semodule -r abrt</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>semodule -l</code></strong>
<code class="computeroutput">accountsd 1.1.0 Disabled acct 1.6.0 [...]</code></pre>
				 <p>
					<span class="command"><strong>semodule</strong></span> immediately loads the new configuration unless you use its <code class="literal">-n</code> option. It is worth noting that the program acts by default on the current configuration (which is indicated by the <code class="literal">SELINUXTYPE</code> variable in <code class="filename">/etc/selinux/config</code>), but that you can modify another one by specifying it with the <code class="literal">-s</code> option.
				</p>

			</section>
			 <section class="section" id="id-1.17.8.5.8"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.17.8.5.8"/>14.5.3.2. Managing Identities</h4></div></div></div>
				
				 <p>
					Every time that a user logs in, they get assigned an SELinux identity. This identity defines the roles that they will be able to endorse. Those two mappings (from the user to the identity and from this identity to roles) are configurable with the <span class="command"><strong>semanage</strong></span> command.
				</p>
				 <p>
					You should definitely read the <span class="citerefentry"><span class="refentrytitle">semanage</span>
					(8)</span> manual page, even if the command's syntax tends to be similar for all the concepts which are managed. You will find common options to all sub-commands: <code class="literal">-a</code> to add, <code class="literal">-d</code> to delete, <code class="literal">-m</code> to modify, <code class="literal">-l</code> to list, and <code class="literal">-t</code> to indicate a type (or domain).
				</p>
				 <p>
					<span class="command"><strong>semanage login -l</strong></span> lists the current mapping between user identifiers and SELinux identities. Users that have no explicit entry get the identity indicated in the <code class="literal">__default__</code> entry. The <span class="command"><strong>semanage login -a -s user_u <em class="replaceable">user</em></strong></span> command will associate the <span class="emphasis"><em>user_u</em></span> identity to the given user. Finally, <span class="command"><strong>semanage login -d <em class="replaceable">user</em></strong></span> drops the mapping entry assigned to this user.
				</p>
				 
<pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>semanage login -a -s user_u rhertzog</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>semanage login -l</code></strong>
<code class="computeroutput"> Login Name SELinux User MLS/MCS Range Service __default__ unconfined_u SystemLow-SystemHigh * rhertzog user_u SystemLow * root unconfined_u SystemLow-SystemHigh * system_u system_u SystemLow-SystemHigh * # </code><strong class="userinput"><code>semanage login -d rhertzog</code></strong></pre>
				 <p>
					<span class="command"><strong>semanage user -l</strong></span> lists the mapping between SELinux user identities and allowed roles. Adding a new identity requires to define both the corresponding roles and a labeling prefix which is used to assign a type to personal files (<code class="filename">/home/<em class="replaceable">user</em>/*</code>). The prefix must be picked among <code class="literal">user</code>, <code class="literal">staff</code>, and <code class="literal">sysadm</code>. The “<code class="literal">staff</code>” prefix results in files of type “<code class="literal">staff_home_dir_t</code>”. Creating a new SELinux user identity is done with <span class="command"><strong>semanage user -a -R <em class="replaceable">roles</em> -P <em class="replaceable">prefix</em> <em class="replaceable">identity</em></strong></span>. Finally, you can remove an SELinux user identity with <span class="command"><strong>semanage user -d <em class="replaceable">identity</em></strong></span>.
				</p>
				 
<pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>semanage user -a -R 'staff_r user_r' -P staff test_u</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>semanage user -l</code></strong>
<code class="computeroutput"> Labeling MLS/ MLS/ SELinux User Prefix MCS Level MCS Range SELinux Roles root sysadm SystemLow SystemLow-SystemHigh staff_r sysadm_r system_r staff_u staff SystemLow SystemLow-SystemHigh staff_r sysadm_r sysadm_u sysadm SystemLow SystemLow-SystemHigh sysadm_r system_u user SystemLow SystemLow-SystemHigh system_r test_u staff SystemLow SystemLow staff_r user_r unconfined_u unconfined SystemLow SystemLow-SystemHigh system_r unconfined_r user_u user SystemLow SystemLow user_r # </code><strong class="userinput"><code>semanage user -d test_u</code></strong></pre>

			</section>
			 <section class="section" id="id-1.17.8.5.9"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.17.8.5.9"/>14.5.3.3. Managing File Contexts, Ports and Booleans</h4></div></div></div>
				
				 <p>
					Each SELinux module provides a set of file labeling rules, but it is also possible to add custom labeling rules to cater to a specific case. For example, if you want the web server to be able to read files within the <code class="filename">/srv/www/</code> file hierarchy, you could execute <span class="command"><strong>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</strong></span> followed by <span class="command"><strong>restorecon -R /srv/www/</strong></span>. The former command registers the new labeling rules and the latter resets the file types according to the current labeling rules.
				</p>
				 <p>
					Similarly, TCP/UDP ports are labeled in a way that ensures that only the corresponding daemons can listen to them. For instance, if you want the web server to be able to listen on port 8080, you should run <span class="command"><strong>semanage port -m -t http_port_t -p tcp 8080</strong></span>.
				</p>
				 <p>
					Some SELinux modules export boolean options that you can tweak to alter the behavior of the default rules. The <span class="command"><strong>getsebool</strong></span> utility can be used to inspect those options (<span class="command"><strong>getsebool <em class="replaceable">boolean</em></strong></span> displays one option, and <span class="command"><strong>getsebool -a</strong></span> them all). The <span class="command"><strong>setsebool <em class="replaceable">boolean</em> <em class="replaceable">value</em></strong></span> command changes the current value of a boolean option. The <code class="literal">-P</code> option makes the change permanent, it means that the new value becomes the default and will be kept across reboots. The example below grants web servers an access to home directories (this is useful when users have personal websites in <code class="filename">~/public_html/</code>).
				</p>
				 
<pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>getsebool httpd_enable_homedirs</code></strong>
<code class="computeroutput">httpd_enable_homedirs --&gt; off # </code><strong class="userinput"><code>setsebool -P httpd_enable_homedirs on</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>getsebool httpd_enable_homedirs</code></strong> 
<code class="computeroutput">httpd_enable_homedirs --&gt; on</code></pre>

			</section>

		</section>
		 <section class="section" id="sect.selinux-custom-rules"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.selinux-custom-rules"/>14.5.4. Adapting the Rules</h3></div></div></div>
			
			 <p>
				Since the SELinux policy is modular, it might be interesting to develop new modules for (possibly custom) applications that lack them. These new modules will then complete the <span class="emphasis"><em>reference policy</em></span>.
			</p>
			 <p>
				To create new modules, the <span class="pkg pkg">selinux-policy-dev</span> package is required, as well as <span class="pkg pkg">selinux-policy-doc</span>. The latter contains the documentation of the standard rules (<code class="filename">/usr/share/doc/selinux-policy-doc/html/</code>) and sample files that can be used as templates to create new modules. Install those files and study them more closely:
			</p>
			 
<pre class="screen"><code class="computeroutput">$ </code><strong class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</code></strong>
<code class="computeroutput">$ </code><strong class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.fc ./</code></strong>
<code class="computeroutput">$ </code><strong class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.if ./</code></strong>
<code class="computeroutput">$ </code><strong class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.te ./</code></strong></pre>
			 <p>
				The <code class="filename">.te</code> file is the most important one. It defines the rules. The <code class="filename">.fc</code> file defines the “file contexts”, that is the types assigned to files related to this module. The data within the <code class="filename">.fc</code> file are used during the file labeling step. Finally, the <code class="filename">.if</code> file defines the interface of the module: it is a set of “public functions” that other modules can use to properly interact with the module that you're creating.
			</p>
			 <section class="section" id="id-1.17.8.6.6"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.17.8.6.6"/>14.5.4.1. Writing a <code class="filename">.fc</code> file</h4></div></div></div>
				
				 <p>
					Reading the below example should be sufficient to understand the structure of such a file. You can use regular expressions to assign the same security context to multiple files, or even an entire directory tree.
				</p>
				 <div class="example" id="id-1.17.8.6.6.3"><a xmlns="" id="id-1.17.8.6.6.3"/><p class="title"><strong>Ví dụ 14.2. <code class="filename">example.fc</code> file</strong></p><div class="example-contents">
					
					 
<pre class="programlisting scale scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)
</pre>

				</div></div>

			</section>
			 <section class="section" id="id-1.17.8.6.7"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.17.8.6.7"/>14.5.4.2. Writing a <code class="filename">.if</code> File</h4></div></div></div>
				
				 <p>
					In the sample below, the first interface (“<code class="literal">myapp_domtrans</code>”) controls who can execute the application. The second one (“<code class="literal">myapp_read_log</code>”) grants read rights on the application's log files.
				</p>
				 <p>
					Each interface must generate a valid set of rules which can be embedded in a <code class="filename">.te</code> file. You should thus declare all the types that you use (with the <code class="literal">gen_require</code> macro), and use standard directives to grant rights. Note, however, that you can use interfaces provided by other modules. The next section will give more explanations about how to express those rights.
				</p>
				 <div class="example" id="id-1.17.8.6.7.4"><a xmlns="" id="id-1.17.8.6.7.4"/><p class="title"><strong>Ví dụ 14.3. <code class="filename">example.if</code> File</strong></p><div class="example-contents">
					
					 
<pre class="programlisting">## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')
</pre>

				</div></div>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>DOCUMENTATION</em></span> Explanations about the <span class="emphasis"><em>reference policy</em></span></strong></p></div></div></div> 
				 <p>
					The <span class="emphasis"><em>reference policy</em></span> evolves like any free software project: based on volunteer contributions. The project is hosted by Tresys, one of the most active companies in the SELinux field. Their wiki contains explanations on how the rules are structured and how you can create new ones. <a class="ulink" href="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted">https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted</a>
				</p>
				 </div>
			</section>
			 <section class="section" id="sect.writing-a-te-file"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.writing-a-te-file"/>14.5.4.3. Writing a <code class="filename">.te</code> File</h4></div></div></div>
				
				 <p>
					Have a look at the <code class="filename">example.te</code> file:
				</p>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>GOING FURTHER</em></span> The <span class="command"><strong>m4</strong></span> macro language</strong></p></div></div></div> 
				 <p>
					To properly structure the policy, the SELinux developers used a macro-command processor. Instead of duplicating many similar <span class="emphasis"><em>allow</em></span> directives, they created “macro functions” to use a higher-level logic, which also results in a much more readable policy.
				</p>
				 <p>
					In practice, <span class="command"><strong>m4</strong></span> is used to compile those rules. It does the opposite operation: it expands all those high-level directives into a huge database of <span class="emphasis"><em>allow</em></span> directives.
				</p>
				 <p>
					The SELinux “interfaces” are only macro functions which will be substituted by a set of rules at compilation time. Likewise, some rights are in fact sets of rights which are replaced by their values at compilation time.
				</p>
				 </div> 
<pre class="programlisting">policy_module(myapp,1.0.0) <span id="example.te.module"/><a xmlns="" id="example.te.module"/><span class="callout">1</span>

########################################
#
# Declarations
#

type myapp_t; <span id="example.te.type"/><a xmlns="" id="example.te.type"/><span class="callout">2</span>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <span id="example.te.domain"/><a xmlns="" id="example.te.domain"/><span class="callout">3</span>

type myapp_log_t;
logging_log_file(myapp_log_t) <span id="example.te.interface"/><a xmlns="" id="example.te.interface"/><span class="callout">4</span>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <span id="example.te.allow"/><a xmlns="" id="example.te.allow"/><span class="callout">5</span>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)
</pre>
				 <div class="calloutlist"><dl class="calloutlist"><dt><a href="#example.te.module"><span class="callout">1</span></a> </dt><dd>
						<p>
							The module must be identified by its name and version number. This directive is required.
						</p>

					</dd><dt><a href="#example.te.type"><span class="callout">2</span></a> </dt><dd>
						<p>
							If the module introduces new types, it must declare them with directives like this one. Do not hesitate to create as many types as required rather than granting too many useless rights.
						</p>

					</dd><dt><a href="#example.te.domain"><span class="callout">3</span></a> </dt><dd>
						<p>
							Those interfaces define the <code class="literal">myapp_t</code> type as a process domain that should be used by any executable labeled with <code class="literal">myapp_exec_t</code>. Implicitly, this adds an <code class="literal">exec_type</code> attribute on those objects, which in turn allows other modules to grant rights to execute those programs: for instance, the <code class="literal">userdomain</code> module allows processes with domains <code class="literal">user_t</code>, <code class="literal">staff_t</code>, and <code class="literal">sysadm_t</code> to execute them. The domains of other confined applications will not have the rights to execute them, unless the rules grant them similar rights (this is the case, for example, of <span class="command"><strong>dpkg</strong></span> with its <code class="literal">dpkg_t</code> domain).
						</p>

					</dd><dt><a href="#example.te.interface"><span class="callout">4</span></a> </dt><dd>
						<p>
							<code class="literal">logging_log_file</code> is an interface provided by the reference policy. It indicates that files labeled with the given type are log files which ought to benefit from the associated rules (for example granting rights to <span class="command"><strong>logrotate</strong></span> so that it can manipulate them).
						</p>

					</dd><dt><a href="#example.te.allow"><span class="callout">5</span></a> </dt><dd>
						<p>
							The <code class="literal">allow</code> directive is the base directive used to authorize an operation. The first parameter is the process domain which is allowed to execute the operation. The second one defines the object that a process of the former domain can manipulate. This parameter is of the form “<em class="replaceable">type</em>:<em class="replaceable">class</em>“ where <em class="replaceable">type</em> is its SELinux type and <em class="replaceable">class</em> describes the nature of the object (file, directory, socket, fifo, etc.). Finally, the last parameter describes the permissions (the allowed operations).
						</p>
						 <p>
							Permissions are defined as the set of allowed operations and follow this template: <code class="literal">{ <em class="replaceable">operation1</em> <em class="replaceable">operation2</em> }</code>. However, you can also use macros representing the most useful permissions. The <code class="filename">/usr/share/selinux/devel/include/support/obj_perm_sets.spt</code> lists them.
						</p>
						 <p>
							The following web page provides a relatively exhaustive list of object classes, and permissions that can be granted. <a class="ulink" href="http://www.selinuxproject.org/page/ObjectClassesPerms">http://www.selinuxproject.org/page/ObjectClassesPerms</a>
						</p>

					</dd></dl></div>
				 <p>
					Now you just have to find the minimal set of rules required to ensure that the target application or service works properly. To achieve this, you should have a good knowledge of how the application works and of what kind of data it manages and/or generates.
				</p>
				 <p>
					However, an empirical approach is possible. Once the relevant objects are correctly labeled, you can use the application in permissive mode: the operations that would be forbidden are logged but still succeed. By analyzing the logs, you can now identify the operations to allow. Here is an example of such a log entry:
				</p>
				 
<pre class="programlisting">avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1
</pre>
				 <p>
					To better understand this message, let us study it piece by piece.
				</p>
				 <div class="table" id="id-1.17.8.6.8.10"><a xmlns="" id="id-1.17.8.6.8.10"/><p class="title"><strong>Bảng 14.1. Analysis of an SELinux trace</strong></p><div class="table-contents">
					
					 <table class="lt-4-cols lt-7-rows"><colgroup><col/><col/></colgroup><thead><tr><th>Message</th><th>Description</th></tr></thead><tbody><tr><td> <code class="computeroutput">avc: denied</code> </td><td>An operation has been denied.</td></tr><tr><td> <code class="computeroutput">{ read write }</code> </td><td>This operation required the <code class="literal">read</code> and <code class="literal">write</code> permissions.</td></tr><tr><td> <code class="computeroutput">pid=1876</code> </td><td>The process with PID 1876 executed the operation (or tried to execute it).</td></tr><tr><td> <code class="computeroutput">comm="syslogd"</code> </td><td>The process was an instance of the <code class="literal">syslogd</code> program.</td></tr><tr><td> <code class="computeroutput">name="xconsole"</code> </td><td>The target object was named <code class="literal">xconsole</code>. Sometimes you can also have a “path” variable — with the full path — instead.</td></tr><tr><td> <code class="computeroutput">dev=tmpfs</code> </td><td>The device hosting the target object is a <code class="literal">tmpfs</code> (an in-memory filesystem). For a real disk, you could see the partition hosting the object (for example: “sda3”).</td></tr><tr><td> <code class="computeroutput">ino=5510</code> </td><td>The object is identified by the inode number 5510.</td></tr><tr><td> <code class="computeroutput">scontext=system_u:system_r:syslogd_t:s0</code> </td><td>This is the security context of the process who executed the operation.</td></tr><tr><td> <code class="computeroutput">tcontext=system_u:object_r:device_t:s0</code> </td><td>This is the security context of the target object.</td></tr><tr><td> <code class="computeroutput">tclass=fifo_file</code> </td><td>The target object is a FIFO file.</td></tr></tbody></table>

				</div></div>
				 <p>
					By observing this log entry, it is possible to build a rule that would allow this operation. For example: <code class="literal">allow syslogd_t device_t:fifo_file { read write }</code>. This process can be automated, and it's exactly what the <span class="command"><strong>audit2allow</strong></span> command (of the <span class="pkg pkg">policycoreutils</span> package) offers. This approach is only useful if the various objects are already correctly labeled according to what must be confined. In any case, you will have to carefully review the generated rules and validate them according to your knowledge of the application. Effectively, this approach tends to grant more rights than are really required. The proper solution is often to create new types and to grant rights on those types only. It also happens that a denied operation isn't fatal to the application, in which case it might be better to just add a “<code class="literal">dontaudit</code>” rule to avoid the log entry despite the effective denial.
				</p>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>COMPLEMENTS</em></span> No roles in policy rules</strong></p></div></div></div> 
				 <a id="id-1.17.8.6.8.12.2" class="indexterm"></a>
				 <a id="id-1.17.8.6.8.12.3" class="indexterm"></a>
				 <p>
					It might seem weird that roles do not appear at all when creating new rules. SELinux uses only the domains to find out which operations are allowed. The role intervenes only indirectly by allowing the user to switch to another domain. SELinux is based on a theory known as <span class="emphasis"><em>Type Enforcement</em></span> and the type is the only element that matters when granting rights.
				</p>
				 </div>
			</section>
			 <section class="section" id="id-1.17.8.6.9"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.17.8.6.9"/>14.5.4.4. Compiling the Files</h4></div></div></div>
				
				 <p>
					Once the 3 files (<code class="filename">example.if</code>, <code class="filename">example.fc</code>, and <code class="filename">example.te</code>) match your expectations for the new rules, just run <span class="command"><strong>make NAME=devel</strong></span> to generate a module in the <code class="filename">example.pp</code> file (you can immediately load it with <span class="command"><strong>semodule -i example.pp</strong></span>). If several modules are defined, <span class="command"><strong>make</strong></span> will create all the corresponding <code class="filename">.pp</code> files.
				</p>

			</section>

		</section>

	</section><footer/></body></html>