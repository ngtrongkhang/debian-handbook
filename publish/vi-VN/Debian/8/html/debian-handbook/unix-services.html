<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chương 9. Unix Services</title><meta name="generator" content="publican v4.3.2"/><meta name="keywords" content="System boot, Initscripts, SSH, Telnet, Rights, Permissions, Supervision, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI"/><link rel="prev" href="sect.kernel-installation.html" title="8.11. Installing a Kernel"/><link rel="next" href="sect.remote-login.html" title="9.2. Remote Login"/><link xmlns="" rel="canonical" href="https://debian-handbook.info/browse/vi-VN/stable/unix-services.html"/></head><body onLoad="initSwitchery(); jQuery(&quot;#poptoc&quot;).load('index.html .toc:eq(0)'); jQuery('.programlisting').each(function(i, block){hljs.highlightBlock(block);});" onClick="hide('poptoc');"><header><div id="banner"><a href="http://debian-handbook.info/get/"><span class="text">Download the ebook</span></a></div><ul class="docnav top"><li class="previous"><a accesskey="p" href="sect.kernel-installation.html"><strong>Trước đó</strong></a></li><li class="home" onClick="work=1;showhide('poptoc');">Sổ tay Quản trị Debian</li><li class="next"><a accesskey="n" href="sect.remote-login.html"><strong>Kế tiếp</strong></a></li></ul></header><div id="poptoc" class="hidden"> </div><section xml:lang="vi-VN" class="chapter" id="unix-services"><div class="titlepage"><div><div><h1 class="title"><a xmlns="" id="unix-services"/>Chương 9. Unix Services</h1></div></div></div>
	
	 
	 <div class="highlights"> <p>
		This chapter covers a number of basic services that are common to many Unix systems. All administrators should be familiar with them.
	</p>
	 </div> <section class="section" id="sect.system-boot"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.system-boot"/>9.1. System Boot</h2></div></div></div>
		
		 <a id="id-1.12.4.2" class="indexterm"></a>
		 <p>
			When you boot the computer, the many messages scrolling by on the console display many automatic initializations and configurations that are being executed. Sometimes you may wish to slightly alter how this stage works, which means that you need to understand it well. That is the purpose of this section.
		</p>
		 <p>
			First, the BIOS takes control of the computer, detects the disks, loads the <span class="emphasis"><em>Master Boot Record</em></span>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <span class="command"><strong>init</strong></span>. Frequently, this “root partition” and this <span class="command"><strong>init</strong></span> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process.
		</p>
		 <div class="figure" id="figure.boot-process-systemd"><a id="figure.boot-process-systemd"/><p class="title"><strong>Hình 9.1. Boot sequence of a computer running Linux with systemd</strong></p><div class="figure-contents">
			
			 <div class="mediaobject"><img src="images/startup-systemd.png" alt="Boot sequence of a computer running Linux with systemd"/></div>

		</div></div>
		 <section class="section" id="sect.systemd"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.systemd"/>9.1.1. The systemd init system</h3></div></div></div>
			
			 <p>
				The “real init” is currently provided by <span class="pkg pkg">systemd</span> and this section documents this init system.
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>CULTURE</em></span> Before <span class="command"><strong>systemd</strong></span></strong></p></div></div></div> 
			 <p>
				<span class="command"><strong>systemd</strong></span> is a relatively recent “init system”, and although it was already available, to a certain extent, in <span class="distribution distribution">Wheezy</span>, it has only become the default in Debian <span class="distribution distribution">Jessie</span>. Previous releases relied, by default, on the “System V init” (in the <span class="pkg pkg">sysv-rc</span> package), a much more traditional system. We describe the System V init later on.
			</p>
			 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ALTERNATIVE</em></span> Other boot systems</strong></p></div></div></div> 
			 <p>
				This book describes the boot system used by default in Debian <span class="distribution distribution">Jessie</span> (as implemented by the <span class="pkg pkg">systemd</span> package), as well as the previous default, <span class="pkg pkg">sysvinit</span>, which is derived and inherited from <span class="emphasis"><em>System V</em></span> Unix systems; there are others.
			</p>
			 <p>
				<span class="pkg pkg">file-rc</span> is a boot system with a very simple process. It keeps the principle of runlevels, but replaces the directories and symbolic links with a configuration file, which indicates to <span class="command"><strong>init</strong></span> the processes that must be started and their launch order.
			</p>
			 <p>
				The <span class="command"><strong>upstart</strong></span> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <span class="distribution distribution">Jessie</span>, but is not the default; it comes, in fact, as a replacement for <span class="pkg pkg">sysvinit</span>, and one of the tasks launched by <span class="command"><strong>upstart</strong></span> is to launch the scripts written for traditional systems, especially those from the <span class="pkg pkg">sysv-rc</span> package.
			</p>
			 <p>
				There are also other systems and other operating modes, such as <span class="command"><strong>runit</strong></span> or <span class="command"><strong>minit</strong></span>, but they are relatively specialized and not widespread.
			</p>
			 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SPECIFIC CASE</em></span> Booting from the network</strong></p></div></div></div> 
			 <p>
				In some configurations, the BIOS may be configured not to execute the MBR, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of BIOS and network card.
			</p>
			 <p>
				Booting from the network can be used to launch the <span class="command"><strong>debian-installer</strong></span> or FAI (see <a class="xref" href="installation.html#sect.installation-methods" title="4.1. Installation Methods">Phần 4.1, “Installation Methods”</a>).
			</p>
			 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>BACK TO BASICS</em></span> The process, a program instance</strong></p></div></div></div> 
			 <a id="id-1.12.4.6.6.2" class="indexterm"></a>
			 <p>
				A process is the representation in memory of a running program. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs.
			</p>
			 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SECURITY</em></span> Using a shell as <span class="command"><strong>init</strong></span> to gain root rights</strong></p></div></div></div> 
			 <p>
				By convention, the first process that is booted is the <span class="command"><strong>init</strong></span> program (which is a symbolic link to <code class="filename">/lib/systemd/systemd</code> by default). However, it is possible to pass an <code class="literal">init</code> option to the kernel indicating a different program.
			</p>
			 <a id="id-1.12.4.6.7.3" class="indexterm"></a>
			 <p>
				Any person who is able to access the computer can press the <span class="keycap"><strong>Reset</strong></span> button, and thus reboot it. Then, at the bootloader's prompt, it is possible to pass the <code class="literal">init=/bin/sh</code> option to the kernel to gain root access without knowing the administrator's password.
			</p>
			 <p>
				To prevent this, you can protect the bootloader itself with a password. You might also think about protecting access to the BIOS (a password protection mechanism is almost always available), without which a malicious intruder could still boot the machine on a removable media containing its own Linux system, which they could then use to access data on the computer's hard drives.
			</p>
			 <p>
				Finally, be aware that most BIOS have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…
			</p>
			 </div> <p>
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <code class="literal"><em class="replaceable">key</em> = <em class="replaceable">value</em></code> pairs grouped between <code class="literal">[<em class="replaceable">section</em>]</code> headers. Unit files are stored under <code class="filename">/lib/systemd/system/</code> and <code class="filename">/etc/systemd/system/</code>; they come in several flavours, but we will focus on “services” and “targets” here.
			</p>
			 <p>
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:
			</p>
			 
<pre class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</pre>
			 <p>
				As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</p>
			 <p>
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <code class="literal">local-fs.target</code>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <code class="literal">network-online.target</code> and <code class="literal">sound.target</code>. The dependencies of a target can be listed either within the target file (in the <code class="literal">Requires=</code> line), or using a symbolic link to a service file in the <code class="literal">/lib/systemd/system/<em class="replaceable">targetname</em>.target.wants/</code> directory. For instance, <code class="filename">/etc/systemd/system/printer.target.wants/</code> contains a link to <code class="filename">/lib/systemd/system/cups.service</code>; systemd will therefore ensure CUPS is running in order to reach <code class="literal">printer.target</code>.
			</p>
			 <p>
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</p>
			 <p>
				The first such utility is <span class="command"><strong>systemctl</strong></span>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <span class="command"><strong>systemctl status</strong></span> gives a better view of the services, as well as the related processes. If given the name of a service (as in <span class="command"><strong>systemctl status ntp.service</strong></span>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</p>
			 <p>
				Starting a service by hand is a simple matter of running <span class="command"><strong>systemctl start <em class="replaceable">servicename</em>.service</strong></span>. As one can guess, stopping the service is done with <span class="command"><strong>systemctl stop <em class="replaceable">servicename</em>.service</strong></span>; other subcommands include <span class="command"><strong>reload</strong></span> and <span class="command"><strong>restart</strong></span>.
			</p>
			 <p>
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <span class="command"><strong>systemctl enable <em class="replaceable">servicename</em>.service</strong></span> (or <span class="command"><strong>disable</strong></span>). <span class="command"><strong>is-enabled</strong></span> allows checking the status of the service.
			</p>
			 <p>
				An interesting feature of systemd is that it includes a logging component named <span class="command"><strong>journald</strong></span>. It comes as a complement to more traditional logging systems such as <span class="command"><strong>syslogd</strong></span>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <span class="command"><strong>journalctl</strong></span> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</p>
			 
<pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>journalctl -u ssh.service </code></strong><code class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. -- Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22. Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22. Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting. Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22. Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22. Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2 Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0) </code></pre>
			 <p>
				Another useful command-line flag is <span class="command"><strong>-f</strong></span>, which instructs <span class="command"><strong>journalctl</strong></span> to keep displaying new messages as they are emitted (much in the manner of <span class="command"><strong>tail -f <em class="replaceable">file</em></strong></span>).
			</p>
			 <p>
				If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <span class="command"><strong>systemctl status</strong></span>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</p>
			 
<pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>systemctl status ssh.service </code></strong><code class="computeroutput">● ssh.service - OpenBSD Secure Shell server Loaded: loaded (/lib/systemd/system/ssh.service; enabled) Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS) Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255) Main PID: 1188 (code=exited, status=255) Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state. Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start. Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server. Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state. # </code><strong class="userinput"><code>journalctl -u ssh.service </code></strong><code class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. -- Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22. Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22. Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting. Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22. Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22. Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2 Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0) Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess". Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state. Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess". Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state. Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess". Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state. Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess". Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state. Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess". Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state. Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start. Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server. Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state. # </code><strong class="userinput"><code>vi /etc/ssh/sshd_config </code></strong><code class="computeroutput"># </code><strong class="userinput"><code>systemctl start ssh.service </code></strong><code class="computeroutput"># </code><strong class="userinput"><code>systemctl status ssh.service </code></strong><code class="computeroutput">● ssh.service - OpenBSD Secure Shell server Loaded: loaded (/lib/systemd/system/ssh.service; enabled) Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS) Main PID: 1222 (sshd) CGroup: /system.slice/ssh.service └─1222 /usr/sbin/sshd -D # </code></pre>
			 <p>
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>GOING FURTHER</em></span> Other types of unit files</strong></p></div></div></div>
			 <p>
				We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:
			</p>
			 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<p>
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <span class="command"><strong>inetd</strong></span>. See <span class="citerefentry"><span class="refentrytitle">systemd.socket</span>
						(5)</span>.
					</p>
				</li><li class="listitem">
					<p>
						timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <span class="command"><strong>cron</strong></span> features. See <span class="citerefentry"><span class="refentrytitle">systemd.timer</span>
						(5)</span>.
					</p>
				</li><li class="listitem">
					<p>
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</p>
				</li></ul></div>
			</div>
		</section>
		 <section class="section" id="sect.sysvinit"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.sysvinit"/>9.1.2. The System V init system</h3></div></div></div>
			
			 <p>
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span class="emphasis"><em>sysinit</em></span> step) is <span class="command"><strong>/etc/init.d/rcS</strong></span>, a script that executes all of the programs in the <code class="filename">/etc/rcS.d/</code> directory. <a id="id-1.12.4.7.2.5" class="indexterm"></a> <a id="id-1.12.4.7.2.6" class="indexterm"></a> <a id="id-1.12.4.7.2.7" class="indexterm"></a> <a id="id-1.12.4.7.2.8" class="indexterm"></a>
			</p>
			 <p>
				Among these, you will find successively programs in charge of:
			</p>
			 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<p>
						configuring the console's keyboard;
					</p>

				</li><li class="listitem">
					<p>
						loading drivers: most of the kernel modules are loaded by the kernel itself as the hardware is detected; extra drivers are then loaded automatically when the corresponding modules are listed in <code class="filename">/etc/modules</code>;
					</p>

				</li><li class="listitem">
					<p>
						checking the integrity of filesystems;
					</p>

				</li><li class="listitem">
					<p>
						mounting local partitions;
					</p>

				</li><li class="listitem">
					<p>
						configuring the network;
					</p>

				</li><li class="listitem">
					<p>
						mounting network filesystems (NFS).
					</p>

				</li></ul></div>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>BACK TO BASICS</em></span> Kernel modules and options</strong></p></div></div></div> 
			 <a id="id-1.12.4.7.5.2" class="indexterm"></a>
			 <p>
				Kernel modules also have options that can be configured by putting some files in <code class="filename">/etc/modprobe.d/</code>. These options are defined with directives like this: <code class="literal">options <em class="replaceable">module-name</em> <em class="replaceable">option-name</em>=<em class="replaceable">option-value</em></code>. Several options can be specified with a single directive if necessary.
			</p>
			 <p>
				These configuration files are intended for <span class="command"><strong>modprobe</strong></span> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <span class="pkg pkg">kmod</span> package.
			</p>
			 <a id="id-1.12.4.7.5.5" class="indexterm"></a>
			 <a id="id-1.12.4.7.5.6" class="indexterm"></a>
			 </div> <p>
				After this stage, <span class="command"><strong>init</strong></span> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <span class="command"><strong>/etc/init.d/rc 2</strong></span>, a script that starts all services which are listed in <code class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <span class="command"><strong>insserv</strong></span>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <span class="command"><strong>init</strong></span> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <span class="command"><strong>rsyslog</strong></span>, or port assignment with <span class="command"><strong>portmap</strong></span>) are started first, followed by standard services and the graphical interface (<span class="command"><strong>gdm3</strong></span>).
			</p>
			 <p>
				This dependency-based boot system makes it possible to automate re-numbering, which could be rather tedious if it had to be done manually, and it limits the risks of human error, since scheduling is conducted according to the parameters that are indicated. Another benefit is that services can be started in parallel when they are independent from one another, which can accelerate the boot process.
			</p>
			 <a id="id-1.12.4.7.8" class="indexterm"></a>
			 <a id="id-1.12.4.7.9" class="indexterm"></a>
			 <p>
				<span class="command"><strong>init</strong></span> distinguishes several runlevels, so it can switch from one to another with the <span class="command"><strong>telinit <em class="replaceable">new-level</em></strong></span> command. Immediately, <span class="command"><strong>init</strong></span> executes <span class="command"><strong>/etc/init.d/rc</strong></span> again with the new runlevel. This script will then start the missing services and stop those that are no longer desired. To do this, it refers to the content of the <code class="filename">/etc/rc<em class="replaceable">X</em>.d</code> (where <em class="replaceable">X</em> represents the new runlevel). Scripts starting with “S” (as in “Start”) are services to be started; those starting with “K” (as in “Kill”) are the services to be stopped. The script does not start any service that was already active in the previous runlevel.
			</p>
			 <p>
				By default, System V init in Debian uses four different runlevels:
			</p>
			 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<p>
						Level 0 is only used temporarily, while the computer is powering down. As such, it only contains many “K” scripts.
					</p>

				</li><li class="listitem">
					<p>
						Level 1, also known as single-user mode, corresponds to the system in degraded mode; it includes only basic services, and is intended for maintenance operations where interactions with ordinary users are not desired.
					</p>

				</li><li class="listitem">
					<p>
						Level 2 is the level for normal operation, which includes networking services, a graphical interface, user logins, etc.
					</p>

				</li><li class="listitem">
					<p>
						Level 6 is similar to level 0, except that it is used during the shutdown phase that precedes a reboot.
					</p>

				</li></ul></div>
			 <p>
				Other levels exist, especially 3 to 5. By default they are configured to operate the same way as level 2, but the administrator can modify them (by adding or deleting scripts in the corresponding <code class="filename">/etc/rc<em class="replaceable">X</em>.d</code> directories) to adapt them to particular needs.
			</p>
			 <div class="figure" id="figure.boot-process-sysvinit"><a id="figure.boot-process-sysvinit"/><p class="title"><strong>Hình 9.2. Boot sequence of a computer running Linux with System V init</strong></p><div class="figure-contents">
				
				 <div class="mediaobject"><img src="images/startup-sysvinit.png" alt="Boot sequence of a computer running Linux with System V init"/></div>

			</div></div>
			 <a id="id-1.12.4.7.15" class="indexterm"></a>
			 <p>
				All the scripts contained in the various <code class="filename">/etc/rc<em class="replaceable">X</em>.d</code> directories are really only symbolic links — created upon package installation by the <span class="command"><strong>update-rc.d</strong></span> program — pointing to the actual scripts which are stored in <code class="filename">/etc/init.d/</code>. The administrator can fine tune the services available in each runlevel by re-running <span class="command"><strong>update-rc.d</strong></span> with adjusted parameters. The <span class="citerefentry"><span class="refentrytitle">update-rc.d</span>
				(1)</span> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <code class="literal">remove</code> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <span class="command"><strong>update-rc.d</strong></span> has a somewhat convoluted interface, you may prefer using <span class="command"><strong>rcconf</strong></span> (from the <span class="pkg pkg">rcconf</span> package) which provides a more user-friendly interface.
			</p>
			 <a id="id-1.12.4.7.17" class="indexterm"></a>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>DEBIAN POLICY</em></span> Restarting services</strong></p></div></div></div> 
			 <a id="id-1.12.4.7.18.2" class="indexterm"></a>
			 <a id="id-1.12.4.7.18.3" class="indexterm"></a>
			 <a id="id-1.12.4.7.18.4" class="indexterm"></a>
			 <p>
				The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <span class="command"><strong>service <em class="replaceable">service</em> <em class="replaceable">operation</em></strong></span> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <span class="command"><strong>invoke-rc.d</strong></span> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <code class="filename">.d</code> suffix is used here in a program name, and not in a directory.
			</p>
			 </div> <p>
				Finally, <span class="command"><strong>init</strong></span> starts control programs for various virtual consoles (<span class="command"><strong>getty</strong></span>). It displays a prompt, waiting for a username, then executes <span class="command"><strong>login <em class="replaceable">user</em></strong></span> to initiate a session.
			</p>
			 <a id="id-1.12.4.7.20" class="indexterm"></a>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>VOCABULARY</em></span> Console and terminal</strong></p></div></div></div> 
			 <p>
				The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen.
			</p>
			 <p>
				With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span> through <span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F6</strong></span>.
			</p>
			 <p>
				By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical X11 session (such as <span class="command"><strong>xterm</strong></span>, <span class="command"><strong>gnome-terminal</strong></span> or <span class="command"><strong>konsole</strong></span>).
			</p>
			 </div>
		</section>

	</section>
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
</section><footer/></body></html>