<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>14.4. Introduction to AppArmor</title><meta name="generator" content="publican v4.3.2"/><meta name="keywords" content="Tường lửa, Netfilter, IDS/NIDS"/><link rel="prev" href="sect.supervision.html" title="14.3. Supervision: Prevention, Detection, Deterrence"/><link rel="next" href="sect.selinux.html" title="14.5. Introduction to SELinux"/><link xmlns="" rel="canonical" href="https://debian-handbook.info/browse/vi-VN/stable/sect.apparmor.html"/></head><body onLoad="initSwitchery(); jQuery(&quot;#poptoc&quot;).load('index.html .toc:eq(0)'); jQuery('.programlisting').each(function(i, block){hljs.highlightBlock(block);});" onClick="hide('poptoc');"><header><div id="banner"><a href="http://debian-handbook.info/get/"><span class="text">Download the ebook</span></a></div><ul class="docnav top"><li class="previous"><a accesskey="p" href="sect.supervision.html"><strong>Trước đó</strong></a></li><li class="home" onClick="work=1;showhide('poptoc');">Sổ tay Quản trị Debian</li><li class="next"><a accesskey="n" href="sect.selinux.html"><strong>Kế tiếp</strong></a></li></ul></header><div id="poptoc" class="hidden"> </div><section class="section" id="sect.apparmor"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.apparmor"/>14.4. Introduction to AppArmor</h2></div></div></div>
		
		 <a id="id-1.17.7.2" class="indexterm"></a>
		 <section class="section" id="sect.apparmor-principles"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.apparmor-principles"/>14.4.1. Principles</h3></div></div></div>
			
			 <p>
				AppArmor is a <span class="emphasis"><em>Mandatory Access Control</em></span> (MAC) system built on Linux's LSM (<span class="emphasis"><em>Linux Security Modules</em></span>) interface. In practice, the kernel queries AppArmor before each system call to know whether the process is authorized to do the given operation. Through this mechanism, AppArmor confines programs to a limited set of resources.
			</p>
			 <a id="id-1.17.7.3.3" class="indexterm"></a>
			 <a id="id-1.17.7.3.4" class="indexterm"></a>
			 <p>
				AppArmor applies a set of rules (known as “profile”) on each program. The profile applied by the kernel depends on the installation path of the program being executed. Contrary to SELinux (discussed in <a class="xref" href="sect.selinux.html" title="14.5. Introduction to SELinux">Phần 14.5, “Introduction to SELinux”</a>), the rules applied do not depend on the user. All users face the same set of rules when they are executing the same program (but traditional user permissions still apply and might result in different behaviour!).
			</p>
			 <p>
				AppArmor profiles are stored in <code class="filename">/etc/apparmor.d/</code> and they contain a list of access control rules on resources that each program can make use of. The profiles are compiled and loaded into the kernel by the <span class="command"><strong>apparmor_parser</strong></span> command. Each profile can be loaded either in enforcing or complaining mode. The former enforces the policy and reports violation attempts, while the latter does not enforce the policy but still logs the system calls that would have been denied.
			</p>

		</section>
		 <section class="section" id="sect.apparmor-setup"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.apparmor-setup"/>14.4.2. Enabling AppArmor and managing AppArmor profiles</h3></div></div></div>
			
			 <p>
				AppArmor support is built into the standard kernels provided by Debian. Enabling AppArmor is thus just a matter of installing a few packages and adding some parameters to the kernel command line:
			</p>
			 
<pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>apt install apparmor apparmor-profiles apparmor-utils </code></strong><code class="computeroutput">[...] # </code><strong class="userinput"><code>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub </code></strong><code class="computeroutput"># </code><strong class="userinput"><code>update-grub </code></strong></pre>
			 <p>
				After a reboot, AppArmor is now functional and <span class="command"><strong>aa-status</strong></span> will confirm it quickly:
			</p>
			 
<pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>aa-status</code></strong>
<code class="computeroutput">apparmor module is loaded. 44 profiles are loaded. 9 profiles are in enforce mode. /usr/bin/lxc-start /usr/lib/chromium-browser/chromium-browser//browser_java [...] 35 profiles are in complain mode. /sbin/klogd [...] 3 processes have profiles defined. 1 processes are in enforce mode. /usr/sbin/libvirtd (1295) 2 processes are in complain mode. /usr/sbin/avahi-daemon (941) /usr/sbin/avahi-daemon (1000) 0 processes are unconfined but have a profile defined.</code></pre>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>NOTE</em></span> More AppArmor profiles</strong></p></div></div></div> 
			 <p>
				The <span class="pkg pkg">apparmor-profiles</span> package contains profiles managed by the upstream AppArmor community. To get even more profiles you can install <span class="pkg pkg">apparmor-profiles-extra</span> which contains profiles developed by Ubuntu and Debian.
			</p>
			 </div> <p>
				The state of each profile can be switched between enforcing and complaining with calls to <span class="command"><strong>aa-enforce</strong></span> and <span class="command"><strong>aa-complain</strong></span> giving as parameter either the path of the executable or the path to the policy file. Additionaly a profile can be entirely disabled with <span class="command"><strong>aa-disable</strong></span> or put in audit mode (to log accepted system calls too) with <span class="command"><strong>aa-audit</strong></span>.
			</p>
			 
<pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>aa-enforce /usr/sbin/avahi-daemon</code></strong>
<code class="computeroutput">Setting /usr/sbin/avahi-daemon to enforce mode.</code>
<code class="computeroutput"># </code><strong class="userinput"><code>aa-complain /etc/apparmor.d/usr.bin.lxc-start</code></strong>
<code class="computeroutput">Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</code>
</pre>

		</section>
		 <section class="section" id="sect.apparmor-new-profile"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.apparmor-new-profile"/>14.4.3. Creating a new profile</h3></div></div></div>
			
			 <p>
				Even though creating an AppArmor profile is rather easy, most programs do not have one. This section will show you how to create a new profile from scratch just by using the target program and letting AppArmor monitor the system call it makes and the resources it accesses.
			</p>
			 <p>
				The most important programs that need to be confined are the network facing programs as those are the most likely targets of remote attackers. That is why AppArmor conveniently provides an <span class="command"><strong>aa-unconfined</strong></span> command to list the programs which have no associated profile and which expose an open network socket. With the <code class="literal">--paranoid</code> option you get all unconfined processes that have at least one active network connection.
			</p>
			 
<pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>aa-unconfined</code></strong>
<code class="computeroutput">801 /sbin/dhclient not confined 890 /sbin/rpcbind not confined 899 /sbin/rpc.statd not confined 929 /usr/sbin/sshd not confined 941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)' 988 /usr/sbin/minissdpd not confined 1276 /usr/sbin/exim4 not confined 1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined 1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined 19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</code>
</pre>
			 <p>
				In the following example, we will thus try to create a profile for <span class="command"><strong>/sbin/dhclient</strong></span>. For this we will use <span class="command"><strong>aa-genprof dhclient</strong></span>. It will invite you to use the application in another window and when done to come back to <span class="command"><strong>aa-genprof</strong></span> to scan for AppArmor events in the system logs and convert those logs into access rules. For each logged event, it will make one or more rule suggestions that you can either approve or further edit in multiple ways:
			</p>
			 
<pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>aa-genprof dhclient</code></strong>
<code class="computeroutput">Writing updated profile for /sbin/dhclient. Setting /sbin/dhclient to complain mode. Before you begin, you may wish to check if a profile already exists for the application you wish to confine. See the following wiki page for more information: http://wiki.apparmor.net/index.php/Profiles Please start the application to be profiled in another window and exercise its functionality now. Once completed, select the "Scan" option below in order to scan the system logs for AppArmor events. For each AppArmor event, you will be given the opportunity to choose whether the access should be allowed or denied. Profiling: /sbin/dhclient [(S)can system log for AppArmor events] / (F)inish Reading log entries from /var/log/audit/audit.log. Profile: /sbin/dhclient <span id="aa-genprof-execute"/><a xmlns="" id="aa-genprof-execute"/><span class="callout">1</span> Execute: /usr/lib/NetworkManager/nm-dhcp-helper Severity: unknown (I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish <strong class="userinput"><code>P</code></strong> Should AppArmor sanitise the environment when switching profiles? Sanitising environment is more secure, but some applications depend on the presence of LD_PRELOAD or LD_LIBRARY_PATH. (Y)es / [(N)o] <strong class="userinput"><code>Y</code></strong> Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper. Complain-mode changes: WARN: unknown capability: CAP_net_raw Profile: /sbin/dhclient <span id="aa-genprof-capability"/><a xmlns="" id="aa-genprof-capability"/><span class="callout">2</span> Capability: net_raw Severity: unknown [(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish <strong class="userinput"><code>A</code></strong> Adding capability net_raw to profile. Profile: /sbin/dhclient <span id="aa-genprof-read"/><a xmlns="" id="aa-genprof-read"/><span class="callout">3</span> Path: /etc/nsswitch.conf Mode: r Severity: unknown 1 - #include &lt;abstractions/apache2-common&gt; 2 - #include &lt;abstractions/libvirt-qemu&gt; 3 - #include &lt;abstractions/nameservice&gt; 4 - #include &lt;abstractions/totem&gt; [5 - /etc/nsswitch.conf] [(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore <strong class="userinput"><code>3</code></strong> Profile: /sbin/dhclient Path: /etc/nsswitch.conf Mode: r Severity: unknown 1 - #include &lt;abstractions/apache2-common&gt; 2 - #include &lt;abstractions/libvirt-qemu&gt; [3 - #include &lt;abstractions/nameservice&gt;] 4 - #include &lt;abstractions/totem&gt; 5 - /etc/nsswitch.conf [(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore <strong class="userinput"><code>A</code></strong> Adding #include &lt;abstractions/nameservice&gt; to profile. Profile: /sbin/dhclient Path: /proc/7252/net/dev Mode: r Severity: 6 1 - /proc/7252/net/dev [2 - /proc/*/net/dev] [(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore <strong class="userinput"><code>A</code></strong> Adding /proc/*/net/dev r to profile [...] Profile: /sbin/dhclient <span id="aa-genprof-write"/><a xmlns="" id="aa-genprof-write"/><span class="callout">4</span> Path: /run/dhclient-eth0.pid Mode: w Severity: unknown [1 - /run/dhclient-eth0.pid] [(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore <strong class="userinput"><code>N</code></strong> Enter new path: /run/dhclient*.pid Profile: /sbin/dhclient Path: /run/dhclient-eth0.pid Mode: w Severity: unknown 1 - /run/dhclient-eth0.pid [2 - /run/dhclient*.pid] [(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore <strong class="userinput"><code>A</code></strong> Adding /run/dhclient*.pid w to profile [...] Profile: /usr/lib/NetworkManager/nm-dhcp-helper <span id="aa-genprof-other-profile"/><a xmlns="" id="aa-genprof-other-profile"/><span class="callout">5</span> Path: /proc/filesystems Mode: r Severity: 6 [1 - /proc/filesystems] [(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore <strong class="userinput"><code>A</code></strong> Adding /proc/filesystems r to profile = Changed Local Profiles = The following local profiles were changed. Would you like to save them? [1 - /sbin/dhclient] 2 - /usr/lib/NetworkManager/nm-dhcp-helper (S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t <strong class="userinput"><code>S</code></strong> Writing updated profile for /sbin/dhclient. Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper. Profiling: /sbin/dhclient [(S)can system log for AppArmor events] / (F)inish <strong class="userinput"><code>F</code></strong> Setting /sbin/dhclient to enforce mode. Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode. Reloaded AppArmor profiles in enforce mode. Please consider contributing your new profile! See the following wiki page for more information: http://wiki.apparmor.net/index.php/Profiles Finished generating profile for /sbin/dhclient.</code></pre>
			 <p>
				Note that the program does not display back the control characters that you type but for the clarity of the explanation I have included them in the previous transcript.
			</p>
			 <div class="calloutlist"><dl class="calloutlist"><dt><a href="#aa-genprof-execute"><span class="callout">1</span></a> </dt><dd>
					<p>
						The first event detected is the execution of another program. In that case, you have multiple choices: you can run the program with the profile of the parent process (the “Inherit” choice), you can run it with its own dedicated profile (the “Profile” and the “Named” choices, differing only by the possibility to use an arbitrary profile name), you can run it with a sub-profile of the parent process (the “Child” choice), you can run it without any profile (the “Unconfined” choice) or you can decide to not run it at all (the “Deny” choice).
					</p>
					 <p>
						Note that when you opt to run it under a dedicated profile that doesn't exist yet, the tool will create the missing profile for you and will make rule suggestions for that profile in the same run.
					</p>

				</dd><dt><a href="#aa-genprof-capability"><span class="callout">2</span></a> </dt><dd>
					<p>
						At the kernel level, the special powers of the root user have been split in “capabilities”. When a system call requires a specific capability, AppArmor will verify whether the profile allows the program to make use of this capability.
					</p>

				</dd><dt><a href="#aa-genprof-read"><span class="callout">3</span></a> </dt><dd>
					<p>
						Here the program seeks read permissions for <code class="filename">/etc/nsswitch.conf</code>. <span class="command"><strong>aa-genprof</strong></span> detected that this permission was also granted by multiple “abstractions” and offers them as alternative choices. An abstraction provides a reusable set of access rules grouping together multiple resources that are commonly used together. In this specific case, the file is generally accessed through the nameservice related functions of the C library and we type “3” to first select the “#include &lt;abstractions/nameservice&gt;” choice and then “A” to allow it.
					</p>

				</dd><dt><a href="#aa-genprof-write"><span class="callout">4</span></a> </dt><dd>
					<p>
						The program wants to create the <code class="filename">/run/dhclient-eth0.pid</code> file. If we allow the creation of this specific file only, the program will not work when the user will use it on another network interface. Thus we select “New” to replace the filename with the more generic “/run/dhclient*.pid” before recording the rule with “Allow”.
					</p>

				</dd><dt><a href="#aa-genprof-other-profile"><span class="callout">5</span></a> </dt><dd>
					<p>
						Notice that this access request is not part of the dhclient profile but of the new profile that we created when we allowed <code class="filename">/usr/lib/NetworkManager/nm-dhcp-helper</code> to run with its own profile.
					</p>
					 <p>
						After having gone through all the logged events, the program offers to save all the profiles that were created during the run. In this case, we have two profiles that we save at once with “Save” (but you can save them individually too) before leaving the program with “Finish”.
					</p>

				</dd></dl></div>
			 <p>
				<span class="command"><strong>aa-genprof</strong></span> is in fact only a smart wrapper around <span class="command"><strong>aa-logprof</strong></span>: it creates an empty profile, loads it in complain mode and then run <span class="command"><strong>aa-logprof</strong></span> which is a tool to update a profile based on the profile violations that have been logged. So you can re-run that tool later to improve the profile that you just created.
			</p>
			 <p>
				If you want the generated profile to be complete, you should use the program in all the ways that it is legitimately used. In the case of dhclient, it means running it via Network Manager, running it via ifupdown, running it manually, etc. In the end, you might get a <code class="filename">/etc/apparmor.d/sbin.dhclient</code> close to this:
			</p>
			 
<pre class="programlisting">
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
</pre>

		</section>

	</section><footer/></body></html>