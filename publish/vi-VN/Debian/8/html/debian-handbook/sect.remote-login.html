<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>9.2. Remote Login</title><meta name="generator" content="publican v4.3.2"/><meta name="keywords" content="System boot, Initscripts, SSH, Telnet, Rights, Permissions, Supervision, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI"/><link rel="prev" href="unix-services.html" title="Chương 9. Unix Services"/><link rel="next" href="sect.rights-management.html" title="9.3. Managing Rights"/><link xmlns="" rel="canonical" href="https://debian-handbook.info/browse/vi-VN/stable/sect.remote-login.html"/></head><body onLoad="initSwitchery(); jQuery(&quot;#poptoc&quot;).load('index.html .toc:eq(0)'); jQuery('.programlisting').each(function(i, block){hljs.highlightBlock(block);});" onClick="hide('poptoc');"><header><div id="banner"><a href="http://debian-handbook.info/get/"><span class="text">Download the ebook</span></a></div><ul class="docnav top"><li class="previous"><a accesskey="p" href="unix-services.html"><strong>Trước đó</strong></a></li><li class="home" onClick="work=1;showhide('poptoc');">Sổ tay Quản trị Debian</li><li class="next"><a accesskey="n" href="sect.rights-management.html"><strong>Kế tiếp</strong></a></li></ul></header><div id="poptoc" class="hidden"> </div><section class="section" id="sect.remote-login"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.remote-login"/>9.2. Remote Login</h2></div></div></div>
		
		 <p>
			It is essential for an administrator to be able to connect to a computer remotely. Servers, confined in their own room, are rarely equipped with permanent keyboards and monitors — but they are connected to the network.
		</p>
		 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>BACK TO BASICS</em></span> Client, server</strong></p></div></div></div> 
		 <a id="id-1.12.5.3.2" class="indexterm"></a>
		 <a id="id-1.12.5.3.3" class="indexterm"></a>
		 <p>
			A system where several processes communicate with each other is often described with the “client/server” metaphor. The server is the program that takes requests coming from a client and executes them. It is the client that controls operations, the server doesn't take any initiative of its own.
		</p>
		 </div> <a id="id-1.12.5.4" class="indexterm"></a>
		 <a id="id-1.12.5.5" class="indexterm"></a>
		 <section class="section" id="sect.ssh"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.ssh"/>9.2.1. Secure Remote Login: SSH</h3></div></div></div>
			
			 <a id="id-1.12.5.6.2" class="indexterm"></a>
			 <a id="id-1.12.5.6.3" class="indexterm"></a>
			 <p>
				The <span class="emphasis"><em>SSH</em></span> (Secure SHell) protocol was designed with security and reliability in mind. Connections using SSH are secure: the partner is authenticated and all data exchanges are encrypted.
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>CULTURE</em></span> Telnet and RSH are obsolete</strong></p></div></div></div> 
			 <a id="id-1.12.5.6.5.2" class="indexterm"></a>
			 <a id="id-1.12.5.6.5.3" class="indexterm"></a>
			 <p>
				Before SSH, <span class="emphasis"><em>Telnet</em></span> and <span class="emphasis"><em>RSH</em></span> were the main tools used to login remotely. They are now largely obsolete and should no longer be used even if Debian still provides them.
			</p>
			 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>VOCABULARY</em></span> Authentication, encryption</strong></p></div></div></div> 
			 <p>
				When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is authentication. This identity usually consists of a password that must be kept secret, or any other client could get the password. This is the purpose of encryption, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others.
			</p>
			 <p>
				Authentication and encryption are often mentioned together, both because they are frequently used together, and because they are usually implemented with similar mathematical concepts.
			</p>
			 </div> <p>
				SSH also offers two file transfer services. <span class="command"><strong>scp</strong></span> is a command line tool that can be used like <span class="command"><strong>cp</strong></span>, except that any path to another machine is prefixed with the machine's name, followed by a colon.
			</p>
			 
<pre class="screen"><code class="computeroutput">$ </code><strong class="userinput"><code>scp file machine:/tmp/</code></strong></pre>
			 <p>
				<span class="command"><strong>sftp</strong></span> is an interactive command, similar to <span class="command"><strong>ftp</strong></span>. In a single session, <span class="command"><strong>sftp</strong></span> can transfer several files, and it is possible to manipulate remote files with it (delete, rename, change permissions, etc.).
			</p>
			 <a id="id-1.12.5.6.10" class="indexterm"></a>
			 <a id="id-1.12.5.6.11" class="indexterm"></a>
			 <p>
				Debian uses OpenSSH, a free version of SSH maintained by the <span class="command"><strong>OpenBSD</strong></span> project (a free operating system based on the BSD kernel, focused on security) and fork of the original SSH software developed by the SSH Communications Security Corp company, of Finland. This company initially developed SSH as free software, but eventually decided to continue its development under a proprietary license. The OpenBSD project then created OpenSSH to maintain a free version of SSH.
			</p>
			 <a id="id-1.12.5.6.13" class="indexterm"></a>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>BACK TO BASICS</em></span> <span class="foreignphrase"><em class="foreignphrase">Fork</em></span></strong></p></div></div></div> 
			 <a id="id-1.12.5.6.14.2" class="indexterm"></a>
			 <p>
				A “fork”, in the software field, means a new project that starts as a clone of an existing project, and that will compete with it. From there on, both software will usually quickly diverge in terms of new developments. A fork is often the result of disagreements within the development team.
			</p>
			 <p>
				The option to fork a project is a direct result of the very nature of free software; a fork is a healthy event when it enables the continuation of a project as free software (for example in case of license changes). A fork arising from technical or personal disagreements is often a waste of human resources; another resolution would be preferable. Mergers of two projects that previously went through a prior fork are not unheard of.
			</p>
			 </div> <p>
				OpenSSH is split into two packages: the client part is in the <span class="pkg pkg">openssh-client</span> package, and the server is in the <span class="pkg pkg">openssh-server</span> package. The <span class="pkg pkg">ssh</span> meta-package depends on both parts and facilitates installation of both (<span class="command"><strong>apt install ssh</strong></span>).
			</p>
			 <section class="section" id="sect.ssh-key-based-auth"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.ssh-key-based-auth"/>9.2.1.1. Key-Based Authentication</h4></div></div></div>
				
				 <p>
					Each time someone logs in over SSH, the remote server asks for a password to authenticate the user. This can be problematic if you want to automate a connection, or if you use a tool that requires frequent connections over SSH. This is why SSH offers a key-based authentication system.
				</p>
				 <p>
					The user generates a key pair on the client machine with <span class="command"><strong>ssh-keygen -t rsa</strong></span>; the public key is stored in <code class="filename">~/.ssh/id_rsa.pub</code>, while the corresponding private key is stored in <code class="filename">~/.ssh/id_rsa</code>. The user then uses <span class="command"><strong>ssh-copy-id <em class="replaceable">server</em></strong></span> to add their public key to the <code class="filename">~/.ssh/authorized_keys</code> file on the server. If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <span class="command"><strong>ssh-agent</strong></span> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <span class="command"><strong>ssh-add</strong></span> (once per work session) provided that the session is already associated with a functional instance of <span class="command"><strong>ssh-agent</strong></span>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <code class="filename">/etc/X11/Xsession.options</code>. For a console session, you can manually start it with <span class="command"><strong>eval $(ssh-agent)</strong></span>.
				</p>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SECURITY</em></span> Protection of the private key</strong></p></div></div></div> 
				 <p>
					Whoever has the private key can login on the account thus configured. This is why access to the private key is protected by a “passphrase”. Someone who acquires a copy of a private key file (for example, <code class="filename">~/.ssh/id_rsa</code>) still has to know this phrase in order to be able to use it. This additional protection is not, however, impregnable, and if you think that this file has been compromised, it is best to disable that key on the computers in which it has been installed (by removing it from the <code class="filename">authorized_keys</code> files) and replacing it with a newly generated key.
				</p>
				 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>CULTURE</em></span> OpenSSL flaw in Debian <span class="distribution distribution">Etch</span></strong></p></div></div></div> 
				 <p>
					The OpenSSL library, as initially provided in Debian <span class="distribution distribution">Etch</span>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <span class="command"><strong>valgrind</strong></span>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <a class="ulink" href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a>
				</p>
				 <p>
					Specifically, whenever OpenSSL was used to generate a key, it always produced a key within a known set of hundreds of thousands of keys (32,000 multiplied by a small number of key lengths). This affected SSH keys, SSL keys, and X.509 certificates used by numerous applications, such as OpenVPN. A cracker had only to try all of the keys to gain unauthorized access. To reduce the impact of the problem, the SSH daemon was modified to refuse problematic keys that are listed in the <span class="pkg pkg">openssh-blacklist</span> and <span class="pkg pkg">openssh-blacklist-extra</span> packages. Additionally, the <span class="command"><strong>ssh-vulnkey</strong></span> command allows identification of possibly compromised keys in the system.
				</p>
				 <p>
					A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <span class="command"><strong>valgrind</strong></span>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package.
				</p>
				 <p>
					It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <a class="ulink" href="http://sources.debian.net">http://sources.debian.net</a>
				</p>
				 </div>
			</section>
			 <section class="section" id="sect.ssh-x11"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.ssh-x11"/>9.2.1.2. Using Remote X11 Applications</h4></div></div></div>
				
				 <p>
					The SSH protocol allows forwarding of graphical data (“X11” session, from the name of the most widespread graphical system in Unix); the server then keeps a dedicated channel for those data. Specifically, a graphical program executed remotely can be displayed on the X.org server of the local screen, and the whole session (input and display) will be secure. Since this feature allows remote applications to interfere with the local system, it is disabled by default. You can enable it by specifying <code class="literal">X11Forwarding yes</code> in the server configuration file (<code class="filename">/etc/ssh/sshd_config</code>). Finally, the user must also request it by adding the <code class="literal">-X</code> option to the <span class="command"><strong>ssh</strong></span> command-line.
				</p>

			</section>
			 <section class="section" id="sect.ssh-port-forwarding"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.ssh-port-forwarding"/>9.2.1.3. Creating Encrypted Tunnels with Port Forwarding</h4></div></div></div>
				
				 <a id="id-1.12.5.6.18.2" class="indexterm"></a>
				 <p>
					Its <code class="literal">-R</code> and <code class="literal">-L</code> options allow <span class="command"><strong>ssh</strong></span> to create “encrypted tunnels” between two machines, securely forwarding a local TCP port (see sidebar <a class="xref" href="network-infrastructure.html#sidebar.tcp-udp" title="BACK TO BASICS TCP/UDP"><span class="emphasis"><em>BACK TO BASICS</em></span> TCP/UDP</a>) to a remote machine or vice versa.
				</p>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>VOCABULARY</em></span> Tunnel</strong></p></div></div></div> 
				 <a id="id-1.12.5.6.18.4.2" class="indexterm"></a>
				 <a id="id-1.12.5.6.18.4.3" class="indexterm"></a>
				 <p>
					The Internet, and most LANs that are connected to it, operate in packet mode and not in connected mode, meaning that a packet issued from one computer to another is going to be stopped at several intermediary routers to find its way to its destination. You can still simulate a connected operation where the stream is encapsulated in normal IP packets. These packets follow their usual route, but the stream is reconstructed unchanged at the destination. We call this a “tunnel”, analogous to a road tunnel in which vehicles drive directly from the entrance (input) to the exit (output) without encountering any intersections, as opposed to a path on the surface that would involve intersections and changing direction.
				</p>
				 <p>
					You can use this opportunity to add encryption to the tunnel: the stream that flows through it is then unrecognizable from the outside, but it is returned in decrypted form at the exit of the tunnel.
				</p>
				 </div> <p>
					<span class="command"><strong>ssh -L 8000:server:25 intermediary</strong></span> establishes an SSH session with the <em class="replaceable">intermediary</em> host and listens to local port 8000 (see <a class="xref" href="sect.remote-login.html#figure.ssh-L" title="Hình 9.3. Forwarding a local port with SSH">Hình 9.3, “Forwarding a local port with SSH”</a>). For any connection established on this port, <span class="command"><strong>ssh</strong></span> will initiate a connection from the <em class="replaceable">intermediary</em> computer to port 25 on the <em class="replaceable">server</em>, and will bind both connections together.
				</p>
				 <p>
					<span class="command"><strong>ssh -R 8000:server:25 intermediary</strong></span> also establishes an SSH session to the <em class="replaceable">intermediary</em> computer, but it is on this machine that <span class="command"><strong>ssh</strong></span> listens to port 8000 (see <a class="xref" href="sect.remote-login.html#figure.ssh-R" title="Hình 9.4. Forwarding a remote port with SSH">Hình 9.4, “Forwarding a remote port with SSH”</a>). Any connection established on this port will cause <span class="command"><strong>ssh</strong></span> to open a connection from the local machine on to port 25 of the <em class="replaceable">server</em>, and to bind both connections together.
				</p>
				 <p>
					In both cases, connections are made to port 25 on the <em class="replaceable">server</em> host, which pass through the SSH tunnel established between the local machine and the <em class="replaceable">intermediary</em> machine. In the first case, the entrance to the tunnel is local port 8000, and the data move towards the <em class="replaceable">intermediary</em> machine before being directed to the <em class="replaceable">server</em> on the “public” network. In the second case, the input and output in the tunnel are reversed; the entrance is port 8000 on the <em class="replaceable">intermediary</em> machine, the output is on the local host, and the data are then directed to the <em class="replaceable">server</em>. In practice, the server is usually either the local machine or the intermediary. That way SSH secures the connection from one end to the other.
				</p>
				 <div class="figure" id="figure.ssh-L"><a id="figure.ssh-L"/><p class="title"><strong>Hình 9.3. Forwarding a local port with SSH</strong></p><div class="figure-contents">
					
					 <div class="mediaobject"><img src="images/ssh-L.png" alt="Forwarding a local port with SSH"/></div>

				</div></div>
				 <div class="figure" id="figure.ssh-R"><a id="figure.ssh-R"/><p class="title"><strong>Hình 9.4. Forwarding a remote port with SSH</strong></p><div class="figure-contents">
					
					 <div class="mediaobject"><img src="images/ssh-R.png" alt="Forwarding a remote port with SSH"/></div>

				</div></div>

			</section>

		</section>
		 <section class="section" id="sect.remote-desktops"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.remote-desktops"/>9.2.2. Using Remote Graphical Desktops</h3></div></div></div>
			
			 <p>
				VNC (Virtual Network Computing) allows remote access to graphical desktops.
			</p>
			 <a id="id-1.12.5.7.3" class="indexterm"></a>
			 <a id="id-1.12.5.7.4" class="indexterm"></a>
			 <a id="id-1.12.5.7.5" class="indexterm"></a>
			 <a id="id-1.12.5.7.6" class="indexterm"></a>
			 <a id="id-1.12.5.7.7" class="indexterm"></a>
			 <p>
				This tool is mostly used for technical assistance; the administrator can see the errors that the user is facing, and show them the correct course of action without having to stand by them.
			</p>
			 <a id="id-1.12.5.7.9" class="indexterm"></a>
			 <a id="id-1.12.5.7.10" class="indexterm"></a>
			 <a id="id-1.12.5.7.11" class="indexterm"></a>
			 <p>
				First, the user must authorize sharing their session. The GNOME graphical desktop environment in <span class="distribution distribution">Jessie</span> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <span class="command"><strong>vino</strong></span>). KDE still requires using <span class="command"><strong>krfb</strong></span> to allow sharing an existing session over VNC. For other graphical desktop environments, the <span class="command"><strong>x11vnc</strong></span> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon.
			</p>
			 <a id="id-1.12.5.7.13" class="indexterm"></a>
			 <a id="id-1.12.5.7.14" class="indexterm"></a>
			 <a id="id-1.12.5.7.15" class="indexterm"></a>
			 <a id="id-1.12.5.7.16" class="indexterm"></a>
			 <p>
				When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <span class="command"><strong>vinagre</strong></span> and <span class="command"><strong>remmina</strong></span> for that, while KDE includes <span class="command"><strong>krdc</strong></span> (in the menu at <span class="guimenu">K</span> → <span class="guisubmenu">Internet</span> → <span class="guimenuitem">Remote Desktop Client</span>). There are other VNC clients that use the command line, such as <span class="command"><strong>xvnc4viewer</strong></span> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed.
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SECURITY</em></span> VNC over SSH</strong></p></div></div></div> 
			 <a id="id-1.12.5.7.18.2" class="indexterm"></a>
			 <p>
				If you want to connect by VNC, and you don't want your data sent in clear text on the network, it is possible to encapsulate the data in an SSH tunnel (see <a class="xref" href="sect.remote-login.html#sect.ssh-port-forwarding" title="9.2.1.3. Creating Encrypted Tunnels with Port Forwarding">Phần 9.2.1.3, “Creating Encrypted Tunnels with Port Forwarding”</a>). You simply have to know that VNC uses port 5900 by default for the first screen (called “localhost:0”), 5901 for the second (called “localhost:1”), etc.
			</p>
			 <p>
				The <span class="command"><strong>ssh -L localhost:5901:localhost:5900 -N -T <em class="replaceable">machine</em></strong></span> command creates a tunnel between local port 5901 in the localhost interface and port 5900 of the <em class="replaceable">machine</em> host. The first “localhost” restricts SSH to listening to only that interface on the local machine. The second “localhost” indicates the interface on the remote machine which will receive the network traffic entering in “localhost:5901”. Thus <span class="command"><strong>vncviewer localhost:1</strong></span> will connect the VNC client to the remote screen, even though you indicate the name of the local machine.
			</p>
			 <p>
				When the VNC session is closed, remember to close the tunnel by also quitting the corresponding SSH session.
			</p>
			 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>BACK TO BASICS</em></span> Display manager</strong></p></div></div></div> 
			 <a id="id-1.12.5.7.19.2" class="indexterm"></a>
			 <a id="id-1.12.5.7.19.3" class="indexterm"></a>
			 <a id="id-1.12.5.7.19.4" class="indexterm"></a>
			 <a id="id-1.12.5.7.19.5" class="indexterm"></a>
			 <a id="id-1.12.5.7.19.6" class="indexterm"></a>
			 <a id="id-1.12.5.7.19.7" class="indexterm"></a>
			 <p>
				<span class="command"><strong>gdm3</strong></span>, <span class="command"><strong>kdm</strong></span>, <span class="command"><strong>lightdm</strong></span>, and <span class="command"><strong>xdm</strong></span> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session.
			</p>
			 </div> <p>
				VNC also works for mobile users, or company executives, who occasionally need to login from their home to access a remote desktop similar to the one they use at work. The configuration of such a service is more complicated: you first install the <span class="pkg pkg">vnc4server</span> package, change the configuration of the display manager to accept <code class="literal">XDMCP Query</code> requests (for <span class="command"><strong>gdm3</strong></span>, this can be done by adding <code class="literal">Enable=true</code> in the “xdmcp” section of <code class="filename">/etc/gdm3/daemon.conf</code>), and finally, start the VNC server with <span class="command"><strong>inetd</strong></span> so that a session is automatically started when a user tries to login. For example, you may add this line to <code class="filename">/etc/inetd.conf</code>:
			</p>
			 
<pre class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</pre>
			 <p>
				Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <span class="command"><strong>gdm3</strong></span> login screen (or equivalent <span class="command"><strong>kdm</strong></span>, <span class="command"><strong>xdm</strong></span>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <span class="command"><strong>vncviewer <em class="replaceable">server</em>:50</strong></span>, because the port used is 5950.
			</p>
			 <a id="id-1.12.5.7.23" class="indexterm"></a>

		</section>

	</section><footer/></body></html>