<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>5.2. Package Meta-Information</title><meta name="generator" content="publican v4.3.2"/><meta name="keywords" content="Gói nhị phân, Gói mã nguồn, dpkg, dependencies, conflict"/><link rel="prev" href="packaging-system.html" title="Chương 5. Hệ thống gói: Công cụ và Nguyên tắc cơ bản"/><link rel="next" href="sect.source-package-structure.html" title="5.3. Cấu trúc của Gói nguồn"/><link xmlns="" rel="canonical" href="https://debian-handbook.info/browse/vi-VN/stable/sect.package-meta-information.html"/></head><body onLoad="initSwitchery(); jQuery(&quot;#poptoc&quot;).load('index.html .toc:eq(0)'); jQuery('.programlisting').each(function(i, block){hljs.highlightBlock(block);});" onClick="hide('poptoc');"><header><div id="banner"><a href="http://debian-handbook.info/get/"><span class="text">Download the ebook</span></a></div><ul class="docnav top"><li class="previous"><a accesskey="p" href="packaging-system.html"><strong>Trước đó</strong></a></li><li class="home" onClick="work=1;showhide('poptoc');">Sổ tay Quản trị Debian</li><li class="next"><a accesskey="n" href="sect.source-package-structure.html"><strong>Kế tiếp</strong></a></li></ul></header><div id="poptoc" class="hidden"> </div><section class="section" id="sect.package-meta-information"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.package-meta-information"/>5.2. Package Meta-Information</h2></div></div></div>
		
		 <a id="id-1.8.6.2" class="indexterm"></a>
		 <a id="id-1.8.6.3" class="indexterm"></a>
		 <p>
			Gói Debian không chỉ là một lưu trữ của các tệp tin dành cho cài đặt. Nó là một phần tổng thể lớn hơn, và nó mô tả mối quan hệ với các gói Debian khác (phụ thuộc, xung đột hay gợi ý). Nó còn cung cấp các kịch bản cho phép thực hiện các câu lệnh ở các giai đoạn khác nhau trong vòng đời của gói (cài đặt, gỡ bỏ và nâng cấp). Các dữ liệu này được sử dụng bởi trình quản lý gói nhưng không phải là một phần của phần mềm đóng gói; những dữ liệu trong gói, được gọi với tên là “meta-information” (thông tin về các thông tin khác).
		</p>
		 <section class="section" id="sect.control"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.control"/>5.2.1. Mô tả: tệp tin <code class="filename">control</code></h3></div></div></div>
			
			 <a id="id-1.8.6.5.2" class="indexterm"></a>
			 <a id="id-1.8.6.5.3" class="indexterm"></a>
			 <a id="id-1.8.6.5.4" class="indexterm"></a>
			 <p>
				Tệp này sử dụng một cấu trúc giống như headers của email (định nghĩa ở RFC 2822). Ví dụ, cho gói <span class="pkg pkg">apt</span>, tệp tin <code class="filename">control</code> trông giống như sau:
			</p>
			 
<pre class="screen">
<code class="computeroutput">$ </code><strong class="userinput"><code>apt-cache show apt</code></strong>
<code class="computeroutput">Package: apt Version: 1.0.9.6 Installed-Size: 3788 Maintainer: APT Development Team &lt;deity@lists.debian.org&gt; Architecture: amd64 Replaces: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0) Depends: libapt-pkg4.12 (&gt;= 1.0.9.6), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:4.1.1), libstdc++6 (&gt;= 4.9), debian-archive-keyring, gnupg Suggests: aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), apt-doc, python-apt Conflicts: python-apt (&lt;&lt; 0.7.93.2~) Breaks: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0) Description-en: commandline package manager This package provides commandline tools for searching and managing as well as querying information about packages as a low-level access to all features of the libapt-pkg library. . These include: * apt-get for retrieval of packages and information about them from authenticated sources and for installation, upgrade and removal of packages together with their dependencies * apt-cache for querying available information about installed as well as installable packages * apt-cdrom to use removable media as a source for packages * apt-config as an interface to the configuration settings * apt-key as an interface to manage authentication keys Description-md5: 9fb97a88cb7383934ef963352b53b4a7 Tag: admin::package-management, devel::lang:ruby, hardware::storage, hardware::storage:cd, implemented-in::c++, implemented-in::perl, implemented-in::ruby, interface::commandline, network::client, protocol::ftp, protocol::http, protocol::ipv6, role::program, role::shared-lib, scope::application, scope::utility, sound::player, suite::debian, use::downloading, use::organizing, use::searching, works-with::audio, works-with::software:package, works-with::text Section: admin Priority: important Filename: pool/main/a/apt/apt_1.0.9.6_amd64.deb Size: 1107560 MD5sum: a325ccb14e69fef2c50da54e035a4df4 SHA1: 635d09fcb600ec12810e3136d51e696bcfa636a6 SHA256: 371a559ce741394b59dbc6460470a9399be5245356a9183bbeea0f89ecaabb03</code></pre>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>QUAY VỀ CƠ BẢN</em></span> RFC — Các chuẩn Internet</strong></p></div></div></div> 
			 <a id="id-1.8.6.5.7.2" class="indexterm"></a>
			 <a id="id-1.8.6.5.7.3" class="indexterm"></a>
			 <p>
				RFC là viết tắt của “Request For Comments”. Một RFC nói chung là một tài liệu kỹ thuật mô tả những gì sẽ trở thành một tiêu chuẩn Internet. Trước khi trở thành tiêu chuẩn hóa và đóng băng, các tiêu chuẩn này được gửi cho công cộng xem xét (đó là lý do đặt tên). IETF (Internet Engineering Task Force) quyết định về sự chuyển đổi các trạng thái của các tài liệu (tiêu chuẩn đề xuất, dự thảo tiêu chuẩn, hoặc tiêu chuẩn).
			</p>
			 <p>
				RFC 2026 định nghĩa quá trình tiêu chuẩn hóa của các giao thức Internet. <a class="ulink" href="http://www.faqs.org/rfcs/rfc2026.html">http://www.faqs.org/rfcs/rfc2026.html</a>
			</p>
			 </div> <section class="section" id="id-1.8.6.5.8"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.8.6.5.8"/>5.2.1.1. Các phụ thuộc: trường <code class="literal">Depends</code></h4></div></div></div>
				
				 <a id="id-1.8.6.5.8.2" class="indexterm"></a>
				 <a id="id-1.8.6.5.8.3" class="indexterm"></a>
				 <a id="id-1.8.6.5.8.4" class="indexterm"></a>
				 <p>
					Các phụ thuộc được định nghĩa ở trường <code class="literal">Depends</code> trong tiêu đề gói. Đây là danh sách các điều kiện để đáp ứng cho các gói làm việc chính xác - thông tin này được sử dụng bởi các công cụ như <span class="command"><strong>apt</strong></span> để cài đặt các thư viện cần thiết, với các phiên bản thích hợp phù hợp với các sự phụ thuộc của gói được cài đặt. Đối với mỗi phụ thuộc, nó có thể hạn chế phạm vi của các phiên bản đáp ứng được điều kiện đó. Nói cách khác, nó có thể để bày tỏ một thực tế rằng chúng ta cần gói <span class="pkg pkg">libc6</span> trong một phiên bản tương đương hoặc lớn hơn “2.15” (viết “<span class="command"><strong>libc6 (&gt;= 2.15)</strong></span>”). Toán tử so sánh phiên bản như sau:
				</p>
				 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<p>
							<span class="command"><strong>&lt;&lt;</strong></span>: bé hơn;
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>&lt;=</strong></span>: bé hơn hoặc bằng;
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>=</strong></span>: bằng (hãy nhớ “<code class="literal">2.6.1</code>” không bằng với “<code class="literal">2.6.1-1</code>”);
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>&gt;=</strong></span>: lớn hơn hoặc bằng;
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>&gt;&gt;</strong></span>: lớn hơn.
						</p>

					</li></ul></div>
				 <p>
					Trong danh sách các điều kiện cần đáp ứng, các dấu phẩy xem như là một dấu phân cách. Nó phải được hiểu như là toán tử logic “and”. Trong các điều kiện, các thanh dọc (“|”) thể hiện là một toán tử logic “or” (đó là phép hội “or”, không phải là hoặc cái này hoặc cái kia độc quyền “either/or”). Phép “and” được ưu tiên hơn, nó có thể được sử dụng như nhiều lần khi cần thiết. Do đó, sự phụ thuộc “(A or B) and C” được viết <span class="command"><strong>A | B, C</strong></span>. Ngược lại, khái niệm “A or (B and C)” nên viết là “(A or B) and (A or C)”, khi trường <code class="literal">Depends</code> không có dấu ngoặc mà thay đổi thứ tự ưu tiên giữa các toán tử logic “or” and “and”. Như vậy sẽ được viết thành <span class="command"><strong>A | B, A | C</strong></span>. <a class="ulink" href="http://www.debian.org/doc/debian-policy/ch-relationships.html">http://www.debian.org/doc/debian-policy/ch-relationships.html</a>
				</p>
				 <a id="id-1.8.6.5.8.8" class="indexterm"></a>
				 <p>
					Hệ thống phụ thuộc là một cơ chế tốt để đảm bảo các hoạt động của một chương trình, nhưng nó còn sử dụng cho “meta-packages”. Đây là gói không chứa nội dung chương trình mà chỉ mô tả phụ thuộc. Nó tạo điều kiện cho quá trình cài đặt của một nhóm các chương trình được phù hợp chọn trước bởi nhà bảo trì meta-package; như vậy, <span class="command"><strong>apt install <em class="replaceable">meta-package</em></strong></span> sẽ tự động cài đặt tất cả các chương trình sử dụng các phụ thuộc của meta-package. Các gói <span class="pkg pkg">gnome</span>, <span class="pkg pkg">kde-full</span> and <span class="pkg pkg">linux-image-amd64</span> là ví dụ của meta-packages.
				</p>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>DEBIAN POLICY</em></span> <code class="literal">Pre-Depends</code>, một đòi hỏi nhiều hơn <code class="literal">Depends</code></strong></p></div></div></div> 
				 <a id="id-1.8.6.5.8.10.2" class="indexterm"></a>
				 <a id="id-1.8.6.5.8.10.3" class="indexterm"></a>
				 <p>
					“Pre-dependencies”, mà được liệt kê ở trường “<code class="literal">Pre-Depends</code>” trong tiêu đề gói, ổn định cho sự phụ thuộc bình thường; cú pháp của là giống hệt nhau. Một phụ thuộc bình thường chỉ ra rằng các gói trong trường cần phải được giải nén và cấu hình trước khi cấu hình của gói tuyên bố sự phụ thuộc. Một tiền phụ thuộc (pre) quy định rằng các gói trong trường của nó cần phải được giải nén và cấu hình trước khi thực hiện các kịch bản cài đặt sẵn của gói tuyên bố của tiền phụ thuộc, đó là trước khi cài đặt của nó.
				</p>
				 <p>
					Một phụ thuộc trước là rất cần thiết cho <span class="command"><strong>apt</strong></span>, vì nó thêm một hạn chế nghiêm ngặt về thứ tự các gói để cài đặt. Vì vậy, các phụ thuộc trước không được khuyến khích trừ khi thật sự cần thiết. Thậm chí còn khuyến khích tham khảo các ý kiến từ các nhà phát triển trên <code class="email"><a class="email" href="mailto:debian-devel@lists.debian.org">debian-devel@lists.debian.org</a></code> trước khi thêm một tiền phụ thuộc. Thường có thể tìm thấy giải pháp khác xung quanh vấn đề đấy.
				</p>
				 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>DEBIAN POLICY</em></span> <code class="literal">Recommends</code>, <code class="literal">Suggests</code>, và <code class="literal">Enhances</code> fields</strong></p></div></div></div> 
				 <a id="id-1.8.6.5.8.11.2" class="indexterm"></a>
				 <a id="id-1.8.6.5.8.11.3" class="indexterm"></a>
				 <p>
					Trường <code class="literal">Recommends</code> và <code class="literal">Suggests</code> mô tả các sự phụ thuộc mà không bắt buộc. Trường “recommended”, quan trọng nhất, cải thiện đáng kể các chức năng được cung cấp bởi các gói nhưng không phải là không thể thiếu để hoạt động. Trường “suggested”, quan trọng thứ 2, chỉ ra rằng gói nhất định có thể bổ sung và tăng tiện ích của mình, nhưng nó là hoàn toàn hợp lý để cài đặt một mà không có những cái khác.
				</p>
				 <p>
					Bạn nên thường xuyên cài đặt các gói “recommended”, trừ khi bạn biết chính xác tại sao bạn không cần chúng. Ngược lại, bạn không cần thiết phải cài đặt các gói “suggested” trừ khi bạn biết tại sao bạn cần chúng.
				</p>
				 <a id="id-1.8.6.5.8.11.6" class="indexterm"></a>
				 <p>
					Trường <code class="literal">Enhances</code> cũng miêu tả một sự gợi ý, nhưng có một điều khác biệt. Nó thực sự nằm trong các gói gợi ý, và không có các lợi ích từ sự gợi ý này. Quan tâm của nó nằm ở chỗ có thểm thêm các gợi ý mà không sửa đổi các gói phần mềm liên quan. Do đó, tất cả các add-on, plug-ins, và các thành phần mở rộng khác của một chương trình có thể xuất hiện ở trường này. Mặc dầu nó đã tồn tại trong vài năm, nhưng trường này vẫn bị bỏ qua bởi các chương trình như <span class="command"><strong>apt</strong></span> hoặc <span class="command"><strong>synaptic</strong></span>. Mục đích của nó cho một sự gợi ý từ trường <code class="literal">Enhances</code> cho người dùng trong tìm ra trường <code class="literal">Enhances</code>
				</p>
				 </div>
			</section>
			 <section class="section" id="id-1.8.6.5.9"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.8.6.5.9"/>5.2.1.2. Xung đột: trường <code class="literal">Conflicts</code></h4></div></div></div>
				
				 <a id="id-1.8.6.5.9.2" class="indexterm"></a>
				 <a id="id-1.8.6.5.9.3" class="indexterm"></a>
				 <a id="id-1.8.6.5.9.4" class="indexterm"></a>
				 <p>
					Trường <code class="literal">Conflicts</code> chỉ ra rằng khi một gói không thể cài đặt trong trường hơp với gói khác. Phần lớn lý do chung cho vấn đề này là cả hai gói đều bao gốm giống tên nhau, hoặc cung cấp các dịch vụ như nhau ở cùng cổng TCP, hoặc sẽ cản trở hoạt động của gói kia.
				</p>
				 <p>
					<span class="command"><strong>dpkg</strong></span> sẽ từ chối cài đặt một gói nếu nó gây xung đột với một trong các gói đã cài đặt, ngoại trừ gói mới đặc biệt nó sẽ “thay thế” gói đã cài đặt, trong trường hợp <span class="command"><strong>dpkg</strong></span> sẽ chọn để thay thế gói cũ với gói mới, nó sẽ tự động đề nghị gỡ bỏ gói có vẻ có vấn đề
				</p>

			</section>
			 <section class="section" id="id-1.8.6.5.10"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.8.6.5.10"/>5.2.1.3. Không tương thích: trường <code class="literal">Breaks</code></h4></div></div></div>
				
				 <a id="id-1.8.6.5.10.2" class="indexterm"></a>
				 <a id="id-1.8.6.5.10.3" class="indexterm"></a>
				 <a id="id-1.8.6.5.10.4" class="indexterm"></a>
				 <p>
					Trường <code class="literal">Breaks</code> có tác dụng khá giống với trường <code class="literal">Conflicts</code>, nhưng với một nghĩa đặc biệt. Nó báo hiệu rằng nếu cài đặt gói này sẽ “làm hỏng” gói khác (hoặc cụ thể là phiên bản của nó). Nói chung, sự không thương thích này giữa hai gói là tạm thời, và trường <code class="literal">Breaks</code> quan hệ đặc biệt với các phiên bản không tương thích.
				</p>
				 <p>
					<span class="command"><strong>dpkg</strong></span> sẽ từ chối cài đặt một gói nếu nó làm hỏng một gói đã cài đặt, và <span class="command"><strong>apt</strong></span> sẽ cố giải quyết vấn đề bằng cách cập nhật gói đó lên phiên bản mới nhất (đây là giả định sẽ sửa được và do vậy lại tương thích)
				</p>
				 <p>
					Tình hình này có thể xảy ra trong trường hợp cập nhật mà không tương thích ngược: Trong trường hợp này nếu phiên bản mới hơn không còn các chức năng như phiên bản cũ, và gây ra một sự cố trong chương trình khác mà không làm gì đặc biệt. Trường <code class="literal">Breaks</code> ngăn cản người dùng gặp cả những vấn đề này.
				</p>

			</section>
			 <section class="section" id="id-1.8.6.5.11"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.8.6.5.11"/>5.2.1.4. Cung cấp Các mục: Trường <code class="literal">Provides</code></h4></div></div></div>
				
				 <a id="id-1.8.6.5.11.2" class="indexterm"></a>
				 <p>
					Trường này giới thiệu khái niệm rất thú vị của một “gói ảo”. Nó có nhiều vai trò, nhưng hai trong số đó là quan trọng nhất. Vai trò thứ nhất bao gồm trong sử dụng gói để liên kết với một dịch vụ chung với nó (gói “cung cấp” dịch vụ). Vai trò thứ hai chỉ ra rằng một gói hoàn toàn thay thế một gói khác, và do mục đích này mà nó cũng có thể đáp ứng các phụ thuộc mà gói kia đáp ứng. Do đó có khả năng tạo ra một gói thay thế mà không cần sử dụng cùng tên gói.
				</p>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>VOCABULARY</em></span> Meta-package và virtual package</strong></p></div></div></div> 
				 <a id="id-1.8.6.5.11.4.2" class="indexterm"></a>
				 <a id="id-1.8.6.5.11.4.3" class="indexterm"></a>
				 <a id="id-1.8.6.5.11.4.4" class="indexterm"></a>
				 <p>
					Cần phân biệt rõ ràng các gói meta từ các gói ảo. Trước đây là các gói thực (bao gồm các tập tin thực <code class="filename">.deb</code>), mà mục đích duy nhất của nó là để thể hiện sự phụ thuộc.
				</p>
				 <p>
					Các gói ảo, tuy nhiên, không tồn tại về mặt thể chất; chúng chỉ mang nghĩa để xác định các gói thực dựa trên các tiêu chí chung, hợp lý (cung cấp dịch vụ, khả năng tương thích với một chương trình chuẩn hoặc một có sẵn trước, vv).
				</p>
				 </div> <section class="section" id="id-1.8.6.5.11.5"><div class="titlepage"><div><div><h5 class="title"><a xmlns="" id="id-1.8.6.5.11.5"/>5.2.1.4.1. Đang cung cấp một “Service”</h5></div></div></div>
					
					 <p>
						Chúng ta sẽ thảo luận về trường hợp đầu tiên chi tiết hơn với một ví dụ: tất cả máy chủ mail, ví dụ như <span class="pkg pkg">postfix</span> hoặc <span class="pkg pkg">sendmail</span> “cung cấp” gói <span class="pkg pkg">mail-transport-agent</span> ảo. Thế nên, bất kỳ gói nào cần dịch vụ này để làm tính năng (ví dụ: quản lý mailing list, hay như là <span class="pkg pkg">smartlist</span> hoặc <span class="pkg pkg">sympa</span>) đơn giản là chỉ cần chỉ định phụ thuộc của nó yêu cầu một <span class="pkg pkg">mail-transport-agent</span> thay vi chỉ định một danh sách lớn các giải pháp có thể (ví dụ: <span class="command"><strong>postfix | sendmail | exim4 | …</strong></span>). Hơn nữa, không cần thiết phải cài đặt hai máy chủ mail trên cùng một máy, đó là lý do mỗi gói này tuyên bố xung đột với gói ảo <span class="pkg pkg">mail-transport-agent</span>. Một xung đột giữ gói của chính nó sẽ bị hệ thống bỏ qua nhưng kỹ thuật này sẽ cấm cài đặt hai máy chủ mail song song.
					</p>
					 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>DEBIAN POLICY</em></span> Danh sách các gói ảo</strong></p></div></div></div> 
					 <a id="id-1.8.6.5.11.5.3.2" class="indexterm"></a>
					 <p>
						Đối với các gói ảo là hữu ích, tất cả mọi người phải đồng ý về tên của chúng, đây là lý do tại sao chúng được tiêu chuẩn hóa trong Chính sách Debian, trong đó có một số khác<span class="pkg pkg">mail-transport-agent</span> cho máy chủ mail, <span class="pkg pkg">c-compiler</span> cho trình biên dịch ngôn ngữ lập trình C, u<span class="pkg pkg">www-browser</span> cho các trình duyệt web, <span class="pkg pkg">httpd</span> cho các máy chủ web, <span class="pkg pkg">ftp-server</span> cho máy chủ FTP, u<span class="pkg pkg">x-terminal-emulator</span> cho trình mô phỏng thiết bị đầu cuối ở chế độ đồ hoạ (<span class="command"><strong>xterm</strong></span>), và <span class="pkg pkg">x-window-manager</span> cho các trình quản lý cửa sổ.
					</p>
					 <p>
						Danh sách đầy đủ có thể được tìm thấy trên Web. <a class="ulink" href="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt">http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt</a>
					</p>
					 </div>
				</section>
				 <section class="section" id="id-1.8.6.5.11.6"><div class="titlepage"><div><div><h5 class="title"><a xmlns="" id="id-1.8.6.5.11.6"/>5.2.1.4.2. Khả năng trao đổi với một Gói khác</h5></div></div></div>
					
					 <p>
						Trường <code class="literal">Provides</code> cũng thú vị khi nội dung của một gói được bao gồm trong một gói lớn hơn. Lấy ví dụ: <span class="pkg pkg">libdigest-md5-perl</span> Mô đun Perl là một mô đun tùy chọn trong Perl 5.6 và đã được tích hợp theo chuẩn ở Perl 5.8 (và các phiên bản sau này, như 5.20 có trong <span class="distribution distribution">Jessie</span>). Gói <span class="pkg pkg">perl</span> kể từ phiên bản 5.8 đã tuyên bố <code class="literal">Provides: libdigest-md5-perl</code> để các gói phụ thuộc gói này được đáp ứng nếu người dùng có Perl 5.8 (hoặc mới hơn), gói <span class="pkg pkg">libdigest-md5-perl</span> cuối cùng đã bị xóa, vì nó không còn có mục đích nào khi các phiên bản Perl cũ bị xóa.
					</p>
					 <div class="figure" id="id-1.8.6.5.11.6.3"><a id="id-1.8.6.5.11.6.3"/><p class="title"><strong>Hình 5.1. Sử dụng trường <code class="literal">Provides</code> để không phá vỡ sự phụ thuộc</strong></p><div class="figure-contents">
						
						 <div class="mediaobject"><img src="images/virtual-package.png" alt="Sử dụng trường Provides để không phá vỡ sự phụ thuộc"/></div>

					</div></div>
					 <p>
						Tính năng này rất hữu ích vì không thể lường trước được sự biến động của sự phát triển và cần phải có khả năng điều chỉnh để đổi tên và thay thế tự động các phần mềm đã lỗi thời.
					</p>
					 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>BACK TO BASICS</em></span> Perl, một ngôn ngữ lập trình</strong></p></div></div></div> 
					 <a id="id-1.8.6.5.11.6.5.2" class="indexterm"></a>
					 <a id="id-1.8.6.5.11.6.5.3" class="indexterm"></a>
					 <p>
						Perl (Practical Extraction and Report Language) là một ngôn ngữ lập trình rất phổ biến. Nó có nhiều mô đun sẵn sàng để sử dụng, bao gồm một loạt các ứng dụng rộng lớn và được phân phối bởi các máy chủ CPAN (Mạng Toàn diện Perl Archive), một mạng lưới đầy đủ các gói Perl. <a class="ulink" href="http://www.perl.org/">http://www.perl.org/</a> <a class="ulink" href="http://www.cpan.org/">http://www.cpan.org/</a>
					</p>
					 <p>
						Vì nó là một ngôn thông dịch nên một chương trình được viết bằng Perl không yêu cầu biên dịch trước khi thực hiện. Đây là lý do tại sao chúng được gọi là “các kịch bản Perl”.
					</p>
					 </div>
				</section>
				 <section class="section" id="id-1.8.6.5.11.7"><div class="titlepage"><div><div><h5 class="title"><a xmlns="" id="id-1.8.6.5.11.7"/>5.2.1.4.3. Hạn chế trong Quá khứ</h5></div></div></div>
					
					 <p>
						Các gói ảo được sử dụng để bị một số hạn chế, đáng kể nhất là không có số phiên bản. Trở lại ví dụ trước, một sự phụ thuộc như <code class="literal">Depends: libdigest-md5-perl (&gt;= 1.6)</code>, bất chấp sự có mặt của Perl_5.10, sẽ không bao giờ được coi là thỏa mãn bởi hệ thống gói - trong khi trên thực tế nó rất có thể là thỏa mãn. Không biết về điều này, hệ thống gói đã chọn lựa chọn ít rủi ro nhất, giả định rằng các phiên bản không khớp.
					</p>
					 <p>
						Giới hạn này đã được bỏ trong <span class="pkg pkg">dpkg</span>1.17.11 và không còn liên quan đến Jessie. Gói có thể gán một phiên bản cho gói ảo mà chúng cung cấp với sự phụ thuộc như <code class="literal pkg">Provides: libdigest-md5-perl (= 1.8)</code>.
					</p>

				</section>

			</section>
			 <section class="section" id="id-1.8.6.5.12"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.8.6.5.12"/>5.2.1.5. Thay thế Các tệp: Trường <code class="literal">Replaces</code></h4></div></div></div>
				
				 <a id="id-1.8.6.5.12.2" class="indexterm"></a>
				 <a id="id-1.8.6.5.12.3" class="indexterm"></a>
				 <a id="id-1.8.6.5.12.4" class="indexterm"></a>
				 <p>
					Trường <code class="literal">Replaces</code> chỉ ra rằng gói chứa các tệp có trong gói khác nhưng gói đó có quyền thay thế chúng một cách hợp pháp. Nếu không sử dụng đặc tả này, <code class="literal">dpkg</code> sẽ báo lỗi, nó không thể ghi đè lên các tệp của một gói khác (về mặt kỹ thuật, dĩ nhiên có thể buộc nó làm như vậy với tùy chọn <code class="literal">--force-overwrite</code>, nhưng đó không phải là cách hay). Điều này cho phép xác định các vấn đề tiềm ẩn và yêu cầu người bảo trì phải nghiên cứu vấn đề trước khi lựa chọn có nên thêm vào một trường như thế hay không.
				</p>
				 <p>
					Việc sử dụng trường này là hợp lý khi tên gói thay đổi hoặc khi gói được bao gồm trong một gói khác. Điều này cũng xảy ra khi người bảo trì quyết định phân phối các tệp tin khác nhau giữa các gói nhị phân khác nhau được tạo ra từ cùng một gói nguồn: tệp được thay thế không còn thuộc về gói cũ nữa, nhưng chỉ cần tệp thay thế mới.
				</p>
				 <p>
					Nếu tất cả các tệp trong gói được cài đặt đã được thay thế, gói được coi là đã bị xóa. Cuối cùng, trường này cũng khuyến khích <span class="command"><strong>dpkg</strong></span> để gỡ bỏ gói thay thế nơi có sự xung đột.
				</p>
				 <div class="sidebar" id="sidebar.debtags"><a xmlns="" id="sidebar.debtags"/><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>GOING FURTHER</em></span> Trường <code class="literal">Tag</code></strong></p></div></div></div> 
				 <p>
					Trong ví dụ <span class="pkg pkg">apt</span> ở trên, chúng ta có thể thấy sự hiện diện của một trường mà chúng ta chưa mô tả, trường <code class="literal">Tag</code>. Trường này không mô tả mối quan hệ giữa các gói, nhưng chỉ đơn giản là một cách phân loại một gói theo một chủ đề. Việc phân loại các gói theo một số tiêu chí (kiểu giao diện, ngôn ngữ lập trình, miền ứng dụng, vv) đã có sẵn trong một thời gian dài. Mặc dù vậy, không phải tất cả các gói có thẻ chính xác và nó chưa được tích hợp trong tất cả các công cụ của Debian; <span class="command"><strong>aptitude</strong></span> hiển thị các thẻ này và cho phép chúng được sử dụng làm tiêu chí tìm kiếm. Đối với những người bị không thích tiêu chí tìm kiếm của <span class="command"><strong>aptitude</strong></span>, trang web sau đây cho phép điều hướng cơ sở dữ liệu của thẻ: <a class="ulink" href="http://debtags.alioth.debian.org/">http://debtags.alioth.debian.org/</a>
				</p>
				 </div>
			</section>

		</section>
		 <section class="section" id="sect.configuration-scripts"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.configuration-scripts"/>5.2.2. Kịch bản Cấu hình</h3></div></div></div>
			
			 <a id="id-1.8.6.6.2" class="indexterm"></a>
			 <a id="id-1.8.6.6.3" class="indexterm"></a>
			 <a id="id-1.8.6.6.4" class="indexterm"></a>
			 <a id="id-1.8.6.6.5" class="indexterm"></a>
			 <a id="id-1.8.6.6.6" class="indexterm"></a>
			 <p>
				Ngoài tệp <code class="filename">control</code>, tệp nén <code class="filename">control.tar.gz</code> của mỗi gói Debian có thể chứa một số kịch bản, được gọi bởi <span class="command"><strong>dpkg</strong></span> ở các giai đoạn khác nhau trong việc xử lý gói. Chính sách Debian mô tả có thể có nhiều trường hợp chi tiết, xác định các kịch bản được gọi và các đối số mà chúng nhận được. Các thực hiện kịch bản này có thể phức tạp, vì nếu một trong các kịch bản không thành công, <span class="command"><strong>dpkg</strong></span> sẽ cố gắng trở lại trạng thái trước bằng cách hủy bỏ quá trình cài đặt hoặc xóa bỏ tiến trình (trong chừng mực có thể).
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>GOING FURTHER</em></span> cơ sở dữ liệu của <span class="command"><strong>dpkg</strong></span></strong></p></div></div></div> 
			 <a id="id-1.8.6.6.8.2" class="indexterm"></a>
			 <a id="id-1.8.6.6.8.3" class="indexterm"></a>
			 <p>
				Tất cả các kịch bản cấu hình cho các gói đã được cài đặt đều được lưu trữ trong thư mục <code class="filename">/var/lib/dpkg/info/</code>, dưới dạng một tập tin được đặt tên với tiền tố là tên của gói. Thư mục này cũng bao gồm một tệp có phần mở rộng <code class="filename">.list</code> cho mỗi gói, chứa danh sách các tệp thuộc gói đó.
			</p>
			 <p>
				Tệp tin <code class="filename">/var/lib/dpkg/status</code> chứa một loạt các khối dữ liệu (theo định dạng của tiêu đề thư nổi tiếng, RFC 2822) mô tả trạng thái của mỗi gói. Thông tin từ tệp tin <code class="filename">control</code> của các gói được cài đặt cũng được sao chép ở đó.
			</p>
			 </div> <p>
				Nói chung, kịch bản <code class="filename">preinst</code> được thực hiện trước khi cài đặt gói, trong khi kịch bản <code class="filename">postinst</code> là sau khi cài đặt. Tương tự, <code class="filename">prerm</code> được gọi trước khi loại bỏ một gói và <code class="filename">postrm</code> sau khi loại bỏ gói xong. Bản cập nhật của một gói tương đương với việc loại bỏ phiên bản trước đó và cài đặt gói mới. Không thể mô tả chi tiết tất cả các kịch bản có thể ở đây nhưng chúng ta sẽ thảo luận hai vấn đề phổ biến nhất: cài đặt/cập nhật và gỡ bỏ.
			</p>
			 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>CAUTION</em></span> Tên tượng trưng của kịch bản</strong></p></div></div></div> 
			 <p>
				Trong phần này, chúng ta sẽ gọi các kịch bản cụ thể để phân biệt giữa gói của và gói mới sắp cập nhật, chẳng hạn như là <span class="command"><strong>old-prerm</strong></span> hoặc <span class="command"><strong>new-postinst</strong></span>. Chúng tưng úng là <span class="command"><strong>perm</strong></span> được ở trong phiên bản cũ của gói (được cài đặt trước bản cập nhật) và kịch bản <span class="command"><strong>postinst</strong></span> ở trong tệp mới (bản cập nhật gói mới).
			</p>
			 </div> <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>TIP</em></span> Sơ đồ trạng thái</strong></p></div></div></div> 
			 <p>
				Manoj Srivastava đã làm những sơ đồ này giải thích cách kịch bản cấu hình được gọi bởi <span class="command"><strong>dpkg</strong></span>. Các biểu đồ tương tự cũng đã được dự án Debian Women phát triển; Họ muốn một chút đơn giản để hiểu, nhưng ít hoàn thành hơn. <a class="ulink" href="https://people.debian.org/~srivasta/MaintainerScripts.html">https://people.debian.org/~srivasta/MaintainerScripts.html</a> <a class="ulink" href="https://wiki.debian.org/MaintainerScripts">https://wiki.debian.org/MaintainerScripts</a>
			</p>
			 </div> <section class="section" id="id-1.8.6.6.12"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.8.6.6.12"/>5.2.2.1. Cài đặt và Nâng cấp</h4></div></div></div>
				
				 <a id="id-1.8.6.6.12.2" class="indexterm"></a>
				 <p>
					Dưới đây là những gì xảy ra trong quá trình cài đặt (hoặc cập nhật):
				</p>
				 <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						<p>
							Đối với cập nhật, <span class="command"><strong>dpkg</strong></span> gọi <span class="command"><strong>old-prerm upgrade <em class="replaceable">new-version</em></strong></span>.
						</p>

					</li><li class="listitem">
						<p>
							Vẫn với cập nhật, <span class="command"><strong>dpkg</strong></span> sau đó thực hiện <span class="command"><strong>new-preinst upgrade <em class="replaceable">old-version</em></strong></span>; đối với lần cài đặt đầu tiên, nó thực hiện <span class="command"><strong>new-preinst install</strong></span>. Có thể thêm phiên bản cũ vào tham số theo sau, nếu gói đã được cài đặt và gỡ bỏ trước (nhưng không bị xóa, các tệp cấu hình đã được giữ lại).
						</p>

					</li><li class="listitem">
						<p>
							Các tệp gói mới sau đó được giải nén. Nếu một tập tin đã tồn tại, nó được thay thế, nhưng một bản sao lưu tạm thời được thực hiện.
						</p>

					</li><li class="listitem">
						<p>
							Cho cập nhật, <span class="command"><strong>dpkg</strong></span> thực hiện <span class="command"><strong>old-postrm upgrade <em class="replaceable">new-version</em></strong></span>.
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>dpkg</strong></span> cập nhật tất cả dữ liệu nội bộ (danh sách tệp, tập lệnh cấu hình, v.v.) và loại bỏ các bản sao lưu của các tệp được thay thế. Đây là điểm không trở lại: <span class="command"><strong>dpkg</strong></span> không còn truy cập vào tất cả các yếu tố cần thiết để trở về trạng thái trước đó.
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>dpkg</strong></span> sẽ cập nhật các tệp cấu hình, hỏi người dùng quyết định xem nó có thể tự động quản lý tác vụ này không. Các chi tiết của thủ tục này được thảo luận trong <a class="xref" href="sect.package-meta-information.html#sect.conffiles" title="5.2.3. Checksums, Danh sách Tệp Cấu hình">Phần 5.2.3, “Checksums, Danh sách Tệp Cấu hình”</a>.
						</p>

					</li><li class="listitem">
						<p>
							Cuối cùng, <span class="command"><strong>dpkg</strong></span> cấu hình gói bằng cách thực hiện <span class="command"><strong>new-postinst configure <em class="replaceable">last-version-configured</em></strong></span>.
						</p>

					</li></ol></div>

			</section>
			 <section class="section" id="id-1.8.6.6.13"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="id-1.8.6.6.13"/>5.2.2.2. Xóa Gói</h4></div></div></div>
				
				 <p>
					Dưới đây là những gì xảy ra trong quá trình loại bỏ gói:
				</p>
				 <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						<p>
							<span class="command"><strong>dpkg</strong></span> gọi <span class="command"><strong>prerm remove</strong></span>.
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>dpkg</strong></span> loại bỏ tất cả các tệp của gói, trừ các tệp cấu hình và tập lệnh cấu hình.
						</p>

					</li><li class="listitem">
						<p>
							<span class="command"><strong>dpkg</strong></span> thực hiện <span class="command"><strong>postrm remove</strong></span>. Tất cả các tập lệnh cấu hình, ngoại trừ <code class="filename">postrm</code>, sẽ bị xóa. Nếu người dùng không sử dụng tùy chọn “purge”, quá trình dừng ở đây.
						</p>

					</li><li class="listitem">
						<p>
							Để xóa toàn bộ gói (lệnh được gọi với <span class="command"><strong>dpkg --purge</strong></span> hoặc <span class="command"><strong>dpkg -P</strong></span>), các tệp cấu hình cũng sẽ bị xoá. Cũng như là một số lượng nhất định các bản sao (<code class="filename">*.dpkg-tmp</code>, <code class="filename">*.dpkg-old</code>, <code class="filename">*.dpkg-new</code>) và các tập tin tạm; <code class="filename">dpkg</code> sau đó thực hiện <span class="command"><strong>postrm purge</strong></span>.
						</p>

					</li></ol></div>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>VOCABULARY</em></span> Làm sạch, loại bỏ hoàn toàn</strong></p></div></div></div> 
				 <a id="id-1.8.6.6.13.4.2" class="indexterm"></a>
				 <p>
					Khi một gói Debian được gỡ bỏ, các tệp cấu hình được giữ lại để tạo điều kiện cho việc cài đặt lại. Tương tự, dữ liệu tạo ra bởi một daemon (như nội dung của một thư mục máy chủ LDAP, hoặc nội dung của một cơ sở dữ liệu cho một máy chủ SQL) thường được giữ lại.
				</p>
				 <p>
					Để loại bỏ tất cả các dữ liệu liên quan đến một gói, cần phải “tẩy” gói với lệnh, <span class="command"><strong>dpkg -P <em class="replaceable">package</em></strong></span>, <span class="command"><strong>apt-get remove --purge <em class="replaceable">package</em></strong></span> hoặc <span class="command"><strong>aptitude purge <em class="replaceable">package</em></strong></span>.
				</p>
				 <p>
					Với tính chất dứt khoát của việc xóa dữ liệu, việc tẩy không nên được xem nhẹ.
				</p>
				 </div> <a id="id-1.8.6.6.13.5" class="indexterm"></a>
				 <p>
					Bốn kịch bản được nêu chi tiết ở trên được bổ sung bởi một tập lệnh <code class="filename">config</code>, được cung cấp bởi các gói sử dụng <span class="command"><strong>debconf</strong></span> để thu thập thông tin từ người dùng để cấu hình. Trong quá trình cài đặt, kịch bản này xác định chi tiết các câu hỏi được yêu cầu bởi <span class="command"><strong>debconf</strong></span>. Câu trả lời được ghi lại trong cơ sở dữ liệu <span class="command"><strong>debconf</strong></span> để tham khảo trong tương lai. Tập lệnh thường được thực thi bởi <span class="command"><strong>apt</strong></span> trước khi cài đặt từng gói một để nhóm tất cả các câu hỏi và yêu cầu tất cả các người dùng vào lúc bắt đầu quá trình. Các tập lệnh trước và sau khi cài đặt có thể sử dụng thông tin này để hoạt động theo ý muốn của người dùng.
				</p>
				 <div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>TOOL</em></span> <span class="command"><strong>debconf</strong></span></strong></p></div></div></div> 
				 <a id="id-1.8.6.6.13.7.2" class="indexterm"></a>
				 <p>
					<span class="command"><strong>debconf</strong></span> được tạo ra để giải quyết một vấn đề định kỳ trong Debian. Tất cả các gói Debian không thể hoạt động mà không có cấu hình tối thiểu được sử dụng để đặt câu hỏi với các cuộc gọi tới các lệnh <span class="command"><strong>echo</strong></span> và <span class="command"><strong>read</strong></span> trong kịch bản <code class="filename">postinst</code> (và các kịch bản tương tự khác). Nhưng điều này cũng có nghĩa là trong quá trình cài đặt hoặc cập nhật lớn người dùng phải ở lại máy tính để trả lời các câu hỏi khác nhau có thể phát sinh bất cứ lúc nào. Những tương tác thủ công này đã được hầu như hoàn toàn giải phóng, nhờ công cụ <span class="command"><strong>debconf</strong></span>.
				</p>
				 <p>
					<span class="command"><strong>debconf</strong></span> có nhiều tính năng thú vị: nó đòi hỏi nhà phát triển phải xác định tương tác người dùng; Nó cho phép nội địa hóa tất cả các chuỗi được hiển thị cho người dùng (tất cả các bản dịch được lưu trong tệp <code class="filename">templates</code> mô tả các tương tác); Nó có frontend khác nhau để hiển thị các câu hỏi cho người sử dụng (chế độ văn bản, chế độ đồ họa, không tương tác); Và nó cho phép tạo ra một cơ sở dữ liệu trung tâm của các phản hồi để chia sẻ cùng một cấu hình với một số máy tính... nhưng điều quan trọng nhất là bây giờ có thể trình bày tất cả các câu hỏi liên tiếp với người dùng, trước khi bắt đầu quá trình cài đặt hoặc cập nhật dài hơi. Người sử dụng có thể tiến hành công việc của họ trong khi hệ thống tự quản lý việc cài đặt, mà không cần phải ở lại đó nhìn chằm chằm vào màn hình chờ các câu hỏi.
				</p>
				 </div>
			</section>

		</section>
		 <section class="section" id="sect.conffiles"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.conffiles"/>5.2.3. Checksums, Danh sách Tệp Cấu hình</h3></div></div></div>
			
			 <a id="id-1.8.6.7.2" class="indexterm"></a>
			 <a id="id-1.8.6.7.3" class="indexterm"></a>
			 <a id="id-1.8.6.7.4" class="indexterm"></a>
			 <a id="id-1.8.6.7.5" class="indexterm"></a>
			 <a id="id-1.8.6.7.6" class="indexterm"></a>
			 <p>
				Ngoài các kịch bản bảo trì và dữ liệu điều khiển đã được đề cập trong các phần trước, tệp nén <code class="filename">control.tar.gz</code> của một gói Debian có thể chứa các tệp tin thú vị khác. Đầu tiên, <code class="filename">md5sums</code>, chứa checksums MD5 cho tất cả các tệp của gói. Ưu điểm chính của nó là nó cho phép <span class="command"><strong>dpkg --verify</strong></span> (chúng ta sẽ nghiên cứu trong <a class="xref" href="sect.supervision.html#sect.dpkg-verify" title="14.3.3.1. Auditing Packages with dpkg --verify">Phần 14.3.3.1, “Auditing Packages with <span class="command"><strong>dpkg --verify</strong></span>”</a>) để kiểm tra xem các tệp này đã được sửa đổi từ khi cài đặt hay không. Lưu ý rằng khi tệp này không tồn tại, <span class="command"><strong>dpkg</strong></span> sẽ tự động tạo ra nó trong thời gian cài đặt (và lưu trữ nó trong cơ sở dữ liệu dpkg giống như các tệp kiểm soát khác).
			</p>
			 <p>
				<code class="filename">conffiles</code> liệt kê các tệp tin gói phải được xử lý như tệp cấu hình. Các tệp cấu hình có thể được quản trị viên sửa đổi và <span class="command"><strong>dpkg</strong></span> sẽ cố gắng bảo vệ những thay đổi đó trong quá trình cập nhật gói.
			</p>
			 <p>
				Trong trường hợp này, <span class="command"><strong>dpkg</strong></span> hoạt động thông minh nhất có thể: nếu tập tin cấu hình tiêu chuẩn không thay đổi giữa hai phiên bản, nó không làm gì cả. Tuy nhiên, nếu tệp đã thay đổi, nó sẽ cố gắng cập nhật tệp này. Có hai trường hợp: quản trị viên không chạm vào tệp cấu hình này, trong trường hợp đó <span class="command"><strong>dpkg</strong></span> tự động cài đặt phiên bản mới; Hoặc tập tin đã được sửa đổi, trong trường hợp này <span class="command"><strong>dpkg</strong></span> yêu cầu quản trị viên phiên bản nào họ muốn sử dụng (bản cũ có sửa đổi, hoặc phiên bản mới được cung cấp kèm theo gói). Để hỗ trợ đưa ra quyết định này, <span class="command"><strong>dpkg</strong></span> cung cấp để hiển thị “<span class="command"><strong>diff</strong></span>” cho thấy sự khác biệt giữa hai phiên bản. Nếu người dùng chọn giữ lại phiên bản cũ, tệp mới sẽ được lưu trữ ở cùng vị trí trong một tệp có đuôi <code class="filename">.dpkg-dist</code>. Nếu người dùng chọn phiên bản mới, phần cũ sẽ được giữ lại trong một tệp có đuôi <code class="filename">.dpkg-old</code>. Một hành động khả dụng khác bao gồm tạm ngưng <span class="command"><strong>dpkg</strong></span> để chỉnh sửa tệp và cố gắng cài đặt lại các sửa đổi có liên quan (trước đây được xác định với <span class="command"><strong>diff</strong></span>).
			</p>
			 <div class="sidebar" id="sidebar.questions-conffiles"><a xmlns="" id="sidebar.questions-conffiles"/><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>GOING FURTHER</em></span> Tránh các câu hỏi về tệp cấu hình</strong></p></div></div></div> 
			 <p>
				<span class="command"><strong>dpkg</strong></span> xử lý các bản cập nhật tập tin cấu hình, nhưng, trong khi làm như vậy, thường xuyên ngắt công việc của nó để yêu cầu nhập từ quản trị viên. Điều này làm cho nó ít thú vị hơn cho những ai muốn chạy các bản cập nhật theo cách không tương tác. Đây là lý do tại sao chương trình này cung cấp các tùy chọn cho phép hệ thống tự động trả lời theo logic tương tự: <span class="command"><strong>--force-confold</strong></span> giữ lại phiên bản cũ của tệp; <span class="command"><strong>--force-confnew</strong></span> sẽ sử dụng phiên bản mới của tệp tin (các lựa chọn này được tôn trọng, ngay cả khi tệp không bị thay đổi bởi quản trị viên, điều này hiếm khi có hiệu ứng mong muốn). Thêm tùy chọn <span class="command"><strong>--force-confdef</strong></span> để <span class="command"><strong>dpkg</strong></span> tự quyết định khi có thể (nói cách khác, khi tệp cấu hình ban đầu chưa được chạm vào) và chỉ sử dụng <span class="command"><strong>--force-confnew</strong></span> hoặc <span class="command"><strong>--force-confold</strong></span> cho các trường hợp khác.
			</p>
			 <p>
				Các tùy chọn này áp dụng cho <span class="command"><strong>dpkg</strong></span>, nhưng hầu hết thời gian người quản trị viên sẽ làm việc trực tiếp với chương trình <span class="command"><strong>aptitude</strong></span> hoặc <span class="command"><strong>apt-get</strong></span>. Do đó, cần biết cú pháp được sử dụng để chỉ ra các tùy chọn để vượt qua lệnh <span class="command"><strong>dpkg</strong></span> (các giao diện dòng lệnh của chúng rất giống nhau).
			</p>
			 
<pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</code></strong></pre>
			 <p>
				Các tùy chọn này có thể được lưu trữ trực tiếp trong cấu hình của <span class="command"><strong>apt</strong></span>. Để làm như vậy, chỉ cần viết dòng sau trong tệp <code class="filename"> /etc/apt/apt.conf.d/local</code>:
			</p>
			 <div class="informalexample"> 
<pre class="programlisting">
DPkg::options { "--force-confdef"; "--force-confold"; }</pre>
			 </div> <p>
				Bao gồm tùy chọn này trong tệp cấu hình có nghĩa là nó cũng sẽ được sử dụng trong một giao diện đồ họa như <span class="command"><strong>aptitude</strong></span>.
			</p>
			 </div> <div class="sidebar" id="sidebar.questions-conffiles-bis"><a xmlns="" id="sidebar.questions-conffiles-bis"/><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>GOING FURTHER</em></span> Buộc dpkg yêu cầu hỏi về tệp cấu hình</strong></p></div></div></div> 
			 <p>
				Tùy chọn <span class="command"><strong>--force-confask</strong></span> yêu cầu <span class="command"><strong>dpkg</strong></span> hiển thị các câu hỏi về các tệp cấu hình, ngay cả trong trường hợp không cần thiết. Do đó, khi cài đặt lại một gói với tùy chọn này, <span class="command"><strong>dpkg</strong></span> sẽ hỏi lại tất cả các tập tin cấu hình do quản trị viên sửa đổi. Điều này rất thuận tiện, đặc biệt là để cài đặt lại tập tin cấu hình ban đầu nếu nó đã bị xóa và không có bản sao nào khác có sẵn: trong khi cài đặt lại bình thường sẽ không hoạt động vì <span class="command"><strong>dpkg</strong></span> coi việc xóa như một hình thức sửa đổi hợp pháp, và, do đó không cài đặt các tập tin cấu hình mong muốn.
			</p>
			 </div>
		</section>

	</section><footer/></body></html>